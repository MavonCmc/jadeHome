<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[晚晴幽草轩]]></title>
  <subtitle><![CDATA[It's only too late if you decide it is. Get busy living. or get busy dying!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jeffjade.github.io/"/>
  <updated>2015-11-14T10:36:35.000Z</updated>
  <id>http://jeffjade.github.io/</id>
  
  <author>
    <name><![CDATA[Jeffyang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[CSS实现水平|垂直居中漫谈]]></title>
    <link href="http://jeffjade.github.io/2015/11/14/2015-11-14-css-achieve-horizontal_vertical_center/"/>
    <id>http://jeffjade.github.io/2015/11/14/2015-11-14-css-achieve-horizontal_vertical_center/</id>
    <published>2015-11-14T09:30:00.000Z</published>
    <updated>2015-11-14T10:36:35.000Z</updated>
    <content type="html"><![CDATA[<p>利用CSS进行元素的水平居中，比较简单，手到擒来：行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。而撸起垂直居中，相信于大多初撸者来说，与我相似，内心是抗拒的。于此，以我司同事一内部分享为基，加以搜集完善，得8种CSS垂直居中书写之法；个中有示例Demo，以及代码和优劣之评。</p>
<a id="more"></a>
<ul><br>    <li><a href="/special/horizontal_center-methods.html" style="font-size:1em;font-weight:blod">CSS实现水平居中(3法)</a><br>    </li><br>    <li><a href="/special/vertical_center_methods.html" style="font-size:1em;font-weight:blod">CSS实现垂直居中(8法)</a><br>    </li><br></ul>

<p>PS：窃以为，对于CSS足够熟悉的话，以CSS多种属性组合出的“奇技淫巧”想必是层次不穷的，这里也只是搜集整理了其中为大家常用而又简洁的部分而已。</p>
<hr>
<p><strong>注解:</strong> 好吧，周末被“加班”了耶，搞搞需求整整Blog还算闲适；在写居中示例时，搜肠刮肚没什么适宜之词，便逼的自己“什兴大发“，特胡驺几句自黑乱言，填充内容，耶聊以慰籍；贴之于下，祈与同道者共嗨 😄。</p>
<pre>
    周末把码黄昏后，有咸香盈袖。
    莫道不消魂，独弄键盘，人比黄花瘦。
    真可谓：天堂有路你不走，学海无涯苦作舟。
    到头来：码山有路勤为径？三十功名尘与土。
    饶上个：一入'哀啼'深似海，从此'逍遥'没长'苏'。
</pre>]]></content>
    <summary type="html">
    <![CDATA[<p>利用CSS进行元素的水平居中，比较简单，手到擒来：行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。而撸起垂直居中，相信于大多初撸者来说，与我相似，内心是抗拒的。于此，以我司同事一内部分享为基，加以搜集完善，得8种CSS垂直居中书写之法；个中有示例Demo，以及代码和优劣之评。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://jeffjade.github.io/tags/CSS/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊聊心中功夫明星榜]]></title>
    <link href="http://jeffjade.github.io/2015/11/07/2015-11-07-share-kungfu-star/"/>
    <id>http://jeffjade.github.io/2015/11/07/2015-11-07-share-kungfu-star/</id>
    <published>2015-11-07T10:30:00.000Z</published>
    <updated>2015-11-09T16:27:11.000Z</updated>
    <content type="html"><![CDATA[<p>见识浅薄，故此必然难以周全。仅以所晓明星作品和人生为基点，个人喜好为腔调来絮叨。耗一日之功来敲打，权作祭奠和分享逝去的功夫片陪伴的那些青葱岁月。若有不妥处，还请见谅。</p>
<a id="more"></a>
<h2 id="中国之骄傲李小龙">中国之骄傲<strong>李小龙</strong></h2><p>李小龙(Bruce Lee；1940 11.27 - 1973.07.20)，一代武术宗师、功夫影帝、截拳道创始人、中国功夫首位推广者、好莱坞首位华人演员。开创性地推动了世界武术和功夫电影的发展;将 KungFu（功夫）一词写入了英文词典，犹擅长：思考&amp;恰恰舞&amp;哲学。</p>
<p>短暂的一生，却波澜壮阔，饶是一部励志史诗；却创造和打破了世界纪录协会多项世界之最。如同一颗耀眼的彗星划过国际武坛&amp;影坛的上空，对现代搏击技击术和电影表演艺术的发展作出了巨大的贡献。他主演的功夫片风行海内外，成万人空巷之盛况，令功夫在全世界皆闻名遐迩。32年人生历程的一现昙花，却仅凭四部半电影缔造了不朽的东方传奇&amp;世界奇迹。</p>
<p>无论是功夫还是影坛届，纵使40余年风雨无他，其神一般的存在，影响力也无出其右，更空前而绝后；实乃“前无古人，后无来者”；奈何英年早逝，怎不“念天地之悠悠，独怆然而涕下”？于此榜单，第一，舍他其谁？<br><img src="http://www.jeffjade.com/img/bruceLee.png" alt="李小龙"></p>
<h2 id="功夫皇帝李连杰">功夫皇帝<strong>李连杰</strong></h2><p>李连杰，1963年4月26日出生于中国北京，英文名Jet Li。著名电影演员、国际功夫巨星、武术家、慈善家、“壹基金”创始人，“国际武联会、中国武术协会、世界武博会”形象大使，新加坡籍华人，第27届香港电影金像奖最佳男主角。</p>
<p>自幼习武，曾勇夺武术比赛五连冠。1980年一部《少林寺》令其一举成名，家喻户晓；而后渐红于亚洲，98年则勇闯好莱坞，努力与实力的结合，自然结出胜利的花果。从影后以自己深厚的武术功底让中华传统武术的美感和实战武打完美结合，塑造了几十个令人赞叹的经典艺术影像，并成功扬名好莱坞打下属于自己的一片天地，在电影的民族和世界特质中达到了高度均衡，因其在体育、电影、公益等领域的显赫成就被世人称为东方传奇影星。</p>
<p>于身体，弘扬健康体魄，心体合一，李连杰先生创有“武极”；对生活,低调稳重，极少绯闻。虽有两次婚姻却无遗怨。对于人生，积极而向善，参禅以礼佛，修心悟道，竭力济世。08年遭遇海啸奇迹生还后，更是热衷于慈善，创有“壹基金”，旨在救助遭遇灾难后的苍生。</p>
<p>于武术或是电影，也都具有自己的见解与哲学。一部文戏～《海洋天堂》诠释出深沉父爱。数十部武侠片更是风靡几代年轻人，曾几何时也引领一波习武浪潮。岁月如歌，年轻不在，却如好酒，愈久弥香。君可看他诠释的黄飞鸿，令狐冲，其动作动如脱兔，静如处子，堪称“翩若惊鸿，婉若游龙”；凌厉温厚，潇洒有型。若论功夫秀出的美感，当推首推李连杰之姿。大特爱之，故排其第二 (想必争议不太大)。</p>
<p><img src="http://imga1.pic21.com/bizhi/131013/02300/s11.jpg" alt="李连杰"></p>
<h2 id="(duang)大哥成龙">(duang)大哥<strong>成龙</strong></h2><p>成龙(Jackie Chan)，原名：陈港生;1954年4月7日生于香港太平山，祖籍山东，大中华区影坛巨星和国际功夫电影巨星，在华人世界享有极高声望与影响。成龙明星之路并不顺遂，从武师到龙套，低迷到走红，亚洲冲进好莱坞，基本都是靠着耐心，协同努力，一路打出来的，活脱脱的一个“拼命三郎”；其艰辛程度难以想象。</p>
<p>1997年香港回归，江泽民在宴会上敬酒时称成龙为“大哥”，从此“大哥”的称呼成为了成龙的代名词[出自～@度娘]。</p>
<p>成龙，不仅在华人圈中声望极高，他从一个默默无名的小戏童一路一路伴着苦与伤“打”成为今日尽人皆知，家喻户晓的国际巨星，实属不易。成龙为华人电影也立下了汗马功劳，功不可没。成龙在日本是家喻户晓的人物。在美国洛杉矶、旧金山和加利福尼亚州都定有成龙日，旧金山影展曾授予他特别杰出奖。</p>
<p>成龙一生过于丰富；作为武打明星，起伏命运，套路更迭，一路“打”过来，最终以诙谐功夫喜剧闻名于世；。不愧“大哥”，美人在怀，桃运多丰；一副沧桑嗓音，有十多首经典歌曲。也是社会活动家、慈善事业家。成龙在华人电影界闯出了自己的一片天，一步一个脚印，他的电影和人生传奇还在续写。于“功夫电影”，其为李小龙之后新时代又一旗帜。于拍电影一个“拼”字而言，更是冠绝海内，绝难再有。只是，排榜过于赞李连杰先生，成龙先生也只好屈居于第三位了。</p>
<p><img src="http://img.chinaluxus.com/pic/arct/2011/12/20/20111220153716605.jpg" alt="成龙"></p>
<h2 id="后起之秀吴京">后起之秀<strong>吴京</strong></h2><p>吴京,1974年出生于北京，满族正黄旗。6岁开始在北京市什刹海体校练习武术，1989年进入北京市武术队从事专业训练，师承吴彬。95年第一部电影袁和平执导的《功夫小子闯情关》，饰演杨学文,至今回味都觉大好(其经历神似李连杰先生)。</p>
<p>在电视剧方面从《太极宗师》中的<strong>杨昱乾</strong>,到《小李飞刀》中的<strong>阿飞</strong>，到《策马啸西风》中的<strong>孟星魂</strong>，到《少林武王》中名将后裔<strong>昙志</strong>…每一部都觉经典，记忆犹新。电影方面《杀破狼》中反派杀手jet，《黑拳》中的高岗，《男儿本色》中“天养生”等等矫健的身受，也磨砺了不错的演技；而且能<strong>正邪兼顾</strong>，毫无违和感，可谓是<strong>功夫影星</strong>中难得一枚。</p>
<p>演而优则导。08年有自导自演《狼牙》，个人是回味了蛮多遍。桥段趣而不诙，交锋假确生感动。15年4月有自导自演《战狼》,大获成功。6月18日，主演的功夫电影《杀破狼2》上映,首日票房拿下7200万元；15年的中国功夫电影，舞台是他吴京的。</p>
<p>2014年08月25日，吴京和谢楠的儿子出生，取名：<strong>吴所谓</strong>[来自@度娘]。</p>
<p>在这个<strong>大哥</strong>已老，<strong>皇帝</strong>也退，<strong>鲜肉</strong>横飞功夫青黄不接的年代；本以为舞台将是甄子丹的了；然而鲜有作品问世。而吴京不仅冠绝电视剧，纵然是<strong>电影</strong>也是愈发出彩；更可贵的是其<strong>演而优则导</strong>之后不错的佳绩，实属难能可贵。排其于第四，争议应该不大。并且，不觉得他那“干脆利落，敏捷辣狠”的身手真的很帅么？</p>
<p><img src="http://pic.yiyingt.com/Stills/vod/2013-05-09/146282.jpg" alt="吴京"></p>
<h2 id="功夫明星甄子丹"><strong>功夫明星甄子丹</strong></h2><p>甄子丹,（Donnie Yen，1963年7月27日出生于中国广东武术世家），武术家、演员、导演。参与多部西方电影的演出与幕后，与成龙、李连杰同为国际知名的华人武打演员，他的导火线，杀破狼，等影视都体现了他犀利的武功，据说他在美国唐人街是一霸。以前的人知道李小龙，现在唐人街知道甄子丹同时他还担任香港李小龙协会理事、世界明星厨师联合会副主席。</p>
<p>1997年自导自演电影《战狼传说》。2002年担任《刀锋战士2》动作指导。曾参演多部影视剧，2009年凭借影片《叶问》荣获第16届北京大学生电影节最佳男演员。2011年主演的《武侠》荣获第48届台湾电影金马奖最佳动作设计。</p>
<p>甄子丹身手，可谓大好；其人既精幕后武指，又擅台前猛打，形象不错，实力超群、身手了得[@新华网之评]。其动作干净利落，<strong>凌厉迅猛</strong>，狠而近毒，爆发力强，充满力度与视觉观赏性，在香港诸多的动作演员和武术指导中可谓独成一派(个人感觉，过于严肃，缺少飒爽潇洒)。单论功夫而言，不输前面三位任何一人，只不过，人也命也，奈何没有漂亮的作品横空出世，也只能感叹：“冯唐易老，李广难封”。故此，排其于吴京之后。</p>
<p><img src="http://www.mzyfz.com/newsimg/20090427161448.jpg" alt="甄子丹"></p>
<h2 id="武林大哥洪金宝">武林大哥<strong>洪金宝</strong></h2><p>洪金宝，1949年1月7日原籍浙江宁波，出生于香港，演员、武术指导、导演、监制、编剧以及龙虎武师。是20世纪80年代香港影坛的“大哥大”、“杂家小子”。洪金宝对电影的涉猎很广，曾经担任的工作包括演员、动作指导、导演、监制、编剧以及龙虎武师。曾获得香港电影金像奖最佳男主角奖、亚太影展最佳男主角奖等荣誉。</p>
<p>洪金宝是位多才多艺的动作巨星，而且独具慧眼，在演员、动作指导、导演、监制等方面都取得了卓越成就。他努力、勤奋、敬业、大度，将传统的道德观和崭新的武术理念融会贯通到影片之中，强调人与人之间的朴实情感。他对香港电影贡献良多，带动了香港黑色功夫喜剧片以及时装动作片的潮流（@央视网评）。</p>
<p>洪金宝作品，品尝的不是很多，却破为喜欢。黑色功夫喜剧给人蛮多轻松愉悦的快感。沙场老将，这个年纪仍旧操刀，不容易。而且，他老人家这体型，纵使在年轻的时候，即便翻个跟斗，也比平常人多出出几分好彩来，可谓武行一朵灿烂奇葩(褒义绝对)；怎能不从优揶？</p>
<p><img src="http://www.nmplus.hk/home/wp-content/uploads/2014/11/2_resize6-800x534.jpg" alt="洪金宝"></p>
<h2 id="大帅哥儿赵文卓">大帅哥儿<strong>赵文卓</strong></h2><p>93年，赵文卓参演电影《功夫皇帝方世玉》，那时他19岁。01，02以及03年，分别主演武侠电视剧《风云雄霸天下》《大醉侠》,古装剧《至尊红颜》,那时候看他的作品，被迷的“不要不要的”；时而折枝伪剑，时而削木为剑，闲则随舞，剧间而狂；至今仍不时浮现。</p>
<p>赵文卓本名赵卓，他是风靡亚太惊艳北美的型男「真功夫巨星」。赵文卓俊朗的外形、高强的功夫、爽朗大方的男子汉气概深受海内外观众着迷喜爱。父亲是武术教练，母亲是田径国手，8岁其父即送他从师学习武术，曾是哈尔滨市武术队的成员，擅长于剑、枪和拳术，精通太极拳法，能耍三百多套拳法。1990年考进北京体育大学武术系接受武术训练，从12岁起，即获得大小奖项无数。曾获中国全国锦标赛少年冠军、中国全国大学生比赛全能冠军、全国武术冠军(1991年)和当选中国国家武英级运动健将。1992年获元奎导演赏识进入影视圈拍戏大展拳脚功夫。</p>
<p>1995年，赵文卓在拍摄《满汉全席》时与张国荣建立深厚友谊，经张国荣介绍与梅艳芳相识并相恋，但仅一年就分开了。梅艳芳曾表示如果不是神秘原因，她早已成为“赵太太”。而这个真正的神秘原因，至今没有公开。赵文卓曾说，要对至爱负责，不会将这个秘密公布[From@度娘] 。</p>
<p>其外形俊朗，身受矫健，眉宇间的正气凛然，大为符合心中的“侠客”。并且有作品有品格，实是功夫明星中靓玉一块。唯欠缺集一大成于身，多少有些减分。故只能排名于此了。</p>
<p><img src="http://images.china.cn/news/attachement/jpg/site3/20120303/1285723501583775570.jpg" alt="赵文卓"></p>
<h2 id="功夫美女杨紫琼">功夫美女<strong>杨紫琼</strong></h2><p>杨紫琼（Michelle Yeoh）女，1962年8月6日出生于马来西亚怡保，华人演员，制片人。杨紫琼,并不是从小就开始练武，她生于马来西亚，而且曾当选过“马来西亚小姐”，并曾被香港富豪导演潘迪生心仪迎娶，但后来感情告终。她是不恃姿色，而是走严正演员路线的杰出影星。长期苦练动作片演技，武打动作不仅高难、而且到位，是每一位香港影人都尊敬的阿姐级影星，是香港武打片动作女星的杰出代表，与成龙、李连杰、洪金宝平起平坐，而且在美国也成为很受欢迎的香港影星 ，据传当年日本女打星大岛由加利专门来华挑战杨紫琼结果以失败告终。</p>
<p>她通过“拳脚刀枪”的刻苦敬业塑造了一系列武打片中的形象：《超级警察》中与成龙一起打入黑帮的女警、《明日帝国》中首位亚洲邦德女郎、《卧虎藏龙》中飞檐走壁的江湖女子、《天脉传奇》中背负家族千年命运捍卫宝藏的女中豪杰，以及《飞鹰女侠》中飞越长城的女侠。杨紫琼扮演的角色大都刚强坚毅、成熟聪慧，为“侠骨柔情”做出了很好的诠释。</p>
<p>明明是可以靠脸吃饭的她，却选择了结缘“武打”。于千万女性中，独树一帜。拥抱力量而不失优雅，坚强自信大具芳华，用这人生诠释了一个“东方女侠”，堪称“武林”霸气一姐。<br><img src="http://image72.360doc.com/DownloadImg/2014/05/2301/41851821_6.jpg" alt="杨紫琼"></p>
<h2 id="功夫绿叶于海">功夫绿叶<strong>于海</strong></h2><p>于海，1942年7月18日出生于山东烟台，中国武术家、演员。1954年，拜七星螳螂拳大师林景山先生为师，学习正宗的螳螂拳，历经坎坷，终有成就。</p>
<p>1982年，同武打明星李连杰共同拍摄了由张鑫炎导演执导的武打影片《少林寺》，在剧中于海饰演师父，并兼任该片之动作武术指导。95年@<strong>吴京</strong>处女电影《功夫小子闯情关》，他演绎杨学文(@吴京试)，武艺高超，还不失情调；99年同吴京共同拍摄由张鑫炎导演执导的武打电视剧《新少林寺》，在该影片中于海饰演“一代宗师”昙宗。即便近些年刘德华，成功版本《新少林寺》，他饰演师傅…。这仅仅是记得的那一点，还有一堆不知道的。在功夫电影中，于海师傅，也是一朵永远盛开的花～名字叫“绿叶”！</p>
<p>事实上，于海并非专业演员，银幕上的他飞檐走壁，十八般武艺样样精通，塑造出一个个鲜活的“宗师”形象。性格上，于海性格耿直，凡事随缘而行，随遇而安。多年的武学修为加之对角色的悉心揣摩，让他成为武术界、影视界德高望重的前辈（新华网评价）。</p>
<p><img src="http://www.nicholastse.hk/files/news/p---2.jpg" alt="于海"></p>
<h2 id="功夫老哥刘家良">功夫老哥<strong>刘家良</strong></h2><p>刘家良，1934年7月28日出生于广东省广州市，中国香港导演，武术指导。南派功夫洪家拳的嫡系传人。9岁开始随父亲学武，父亲刘湛是黄飞鸿入室弟子林世荣的亲传弟子。50年代中期刘家良随父进入电影界，演过数以百计的电影，仅黄飞鸿系列就演了几十部，成名作是1965年长城公司的《云海玉弓缘》。</p>
<p>1974年，他与张彻合作在《方世玉与洪熙官》一片中展开正宗国术的路线。但在同年，离开张彻。1975年，刘家良由武指转当导演，开拍《神打》。90年代与成龙合作，推出《醉拳2》等。</p>
<p>刘家良坚持李小龙之后的正宗国术真实武打的路子，他的作品被公认为是真正懂得中国武术且影片深具传统武德精神及家族观念的导演。2010年，刘家良获得了金像奖终身成就奖。</p>
<p>看过老人家的《醉拳Ⅱ》，《七剑》;惜哉，前辈先贤辉煌的那个年代，，还没来得及出生😄，所以无缘得见大师们的顶峰荣光。</p>
<p><img src="http://pic.baike.soso.com/p/20130527/20130527145242-240380703.jpg" alt="刘家良"></p>
<h2 id="功夫老将梁小龙">功夫老将<strong>梁小龙</strong></h2><p>年轻人应该看过他主演的《陈真后转》；周星驰《功夫》中的火云邪神。同李连杰搭档的《不二神探》，真乃老当益壮啊。</p>
<p><a href="http://ww2.sinaimg.cn/mw600/e0f6b799jw1exp7bs6h10j20c63stx3t.jpg" target="_blank" rel="external">梁小龙</a>早在20世纪70年代就在香港演艺圈和李小龙、成龙、狄龙并称为香港演艺圈“四小龙”。祖籍广东的梁小龙生于香港一个贫寒的家庭，15岁时进入武行，并开始做替身演员。</p>
<p>从1973年主演电影《生龙活虎》开始，短短十几年，就拍了《白鹤拳》、《迷魂拳》等70多部电影，后来他进军电视界又连续拍了《射雕英雄传》、《神雕侠侣》、《雪山飞狐》、《霍元甲》、《陈真》、《四大名捕》等1000多集电视剧，成为八十年代初香港最负盛名的武打明星之一。</p>
<p>他先是跟祖父学了三招两式，后来又随戏班里担任武打教师的叔叔学习咏春拳。几年来，叔叔为他打下了坚实的武术根底。后来，他正式拜日本空手道的一位掌门山口刚玄为师，学习搏击整整十年。之后，他又学习了泰国拳和朝鲜拳。</p>
<p>当记者问他：“你的武功属于哪个门派”时，梁小龙笑着说：“在香港和海外，也经常有人向我提出同样的问题，小时候听叔叔讲，他教我的拳脚属于北少林派，非常注重腿功。一个“马步”我就整整练了三年。自从向山口刚玄老师学习搏击以来，吸收了中外百家之长，融会贯通，达到很高的实战功力。</p>
<p>强劲有力的侧踢，跑动中飞身踢腿这些招牌动作使广大影迷记住了梁小龙，虽然他曾经淡出影坛多年，但是他始终没有被人所遗忘!虽然他的很多成绩属于过去，但是鉴于他对功夫电影的贡献和对武术的发扬，“功夫巨星”受之无愧!</p>
<p><img src="http://img.mingxing.com/upload/thumb/2014/05/0-IdavV5.jpg" alt="梁小龙"></p>
<h2 id="十年一剑张晋">十年一剑<strong>张晋</strong></h2><p>那些年看《萧十一郎》，里面有个“雪鹰”，只因诠释出的角色过坏(额，演绎的不错)，记忆犹新；后来看过了《一代宗师》、《杀破狼2》才知道那人叫<strong><a href="http://baike.baidu.com/link?url=NDXU5BfxStGMgPdFiKHcZFrq77ohWkMwZQXNPy2MoBPo228zAKm658xiD7oykIUi7m9HspsfMef7YZQmVArwFtDOPzM89S6buZpxRu6kyCC" target="_blank" rel="external">张晋</a></strong>。</p>
<p>张晋，中国内地男演员，国家武英级武术运动员，1974年5月19日出生于重庆。他9岁习武，11岁进入四川少年武术队，先后取得全国武术比赛陈式太极拳和太极剑冠军，枪术、剑术冠军，八卦掌、醉剑、对练亚军，在第七、八届全国运动会上获得金牌和银牌。</p>
<p>1998年自武术队退役后加入袁和平的“袁家班”从事武术指导。2000年以后逐渐从幕后走向台前，凭借《萧十一郎》、《水月洞天》、《澳门风云》、《一代宗师》、《杀破狼2》等多部影视作品为人所熟知。期间仍兼顾幕后工作，于2003年赴美国好莱坞担任《霹雳娇娃2》《夜魔侠》等影片的武术指导。2007年在《梁山伯与祝英台》中首次担当动作导演。2014年凭借《一代宗师》中的“马三”一角荣获第33届香港电影金像奖“最佳男配角”。</p>
<p>《一代宗师》里的“念念不忘，必有回响”，正好印证了张晋这些年来走过的崎岖路途。当过没名分、没正面镜头的武打替身，遭受过“吃女人软饭”的白眼，这些经验都内化而成张晋演“马三”时心中的那团火。“马三”的绝技“老猿挂印”，其实还有一个连续技叫“回首岁月”，无论如何，张晋熬出头了，有了《一代宗师》，别人终于不再只记得他是“蔡少芬丈夫”（南方都市报评）。</p>
<p>个人倒对《杀破狼2》中张晋饰演的大反派，喜欢的不能自已。文戏武戏，表演皆很出色。尤其动作极为干脆利落没有废招，且力量十足美感充盈；以一敌二，不落下风；其形大有<strong>翩若惊鸿，宛若游龙</strong>之姿，完美的诠释了“头可断发型不能乱，血可流皮鞋不能不擦油”的最高境界；帅到看的女人看到湿，男人看到跪舔有木有？当然张晋死的也很惨，被自己帅死的，他妹的谁打斗还系领带，太帅会死啊太帅会死，记住了<a href="http://www.zhihu.com/question/31417541/answer/52098065" target="_blank" rel="external">SeeHere</a>；既已入道，其前途不可限量。</p>
<p><img src="http://epaper.hilizi.com/bdcb/20150701/188455.jpg" alt="张晋"></p>
<h2 id="功夫小子释小龙">功夫小子<strong>释小龙</strong></h2><p>释小龙，本名陈小龙，1988年1月6日，生于河南郑州，中国男演员。1990年，两岁时拜少林寺第30代接法传人释永信为师，赐法名：释小龙。在1992年中国郑州国际少林武术节表演中，获得少林通臂拳、罗汉棍两项优秀奖。</p>
<p>想必很多人也会记得他诠释的小<strong>展昭</strong>，和少年的<strong>黄飞鸿</strong>吧。1993年8月，与台湾歌星林志颖合拍了第一部影片《旋风小子》。1994年4月与香港影星吴孟达、郑少秋合拍了《新乌龙院》，在台湾创下了两亿的票房成绩，8月与台湾影星金城武、叶全真在美国拍摄了影片《中国龙》，在中国拍摄了《武尊少林》、《少林雄风》等一系列电视片…太多了，幼时的他的确可爱无敌，诠释的角色更是深得民众喜爱，其火红度，想必也是一时无二；只是，随着年岁的增长，身宽体胖了就，也鲜有好作品，实在是可惜。</p>
<h2 id=""><img src="http://p9.qhimg.com/t010e3e615c1fbd5c55.jpg" alt="释小龙"></h2><p><strong>注解：</strong>另有诸多功夫明星，鉴于篇幅(当然也因不多熟悉，就不赘述)然而，他们的名字定然会长存于这功夫影史；譬如我知道的那些大名鼎鼎：</p>
<hr>
<p>一代武师<strong>林正英</strong><br>剑术大师<strong>于承惠</strong><br>七小福之<strong>元彪</strong><br>七小福之<strong>元华</strong><br>武打老姐<strong>郑佩佩</strong><br>武术好手<strong><a href="http://baike.baidu.com/subview/36323/6295788.htm" target="_blank" rel="external">吴樾</a></strong></p>
<p>大反派<strong>邹兆龙</strong><br>大反派<strong>计春华</strong></p>
<p>亦正亦邪<strong>樊少皇</strong><br>亦正亦邪<strong>钱小豪</strong><br>亦正亦邪<strong>释延能</strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/link?url=xd5XdWi-7MIxqrM_E3AFPNFtovdusxwUh-ub0wtaJEqNa5gJIYIfAtCY9RiL_umuEZ549CTdWt7ShxvA34EZTK" target="_blank" rel="external">梁家仁</a></strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/item/刘家辉/5482824" target="_blank" rel="external">刘家辉</a></strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/view/302262.htm" target="_blank" rel="external">熊欣欣</a></strong></p>
<p>腿法超棒<strong>林国斌</strong><br>脚功超群<strong>卢惠光</strong></p>
<p>实力武胜<strong>于荣光</strong><br>世界拳王<strong>周比利</strong></p>
<hr>
<p>另有一些无太棒功夫底子的演员，却也给影视武侠/武打带来诸多不可磨灭贡献；譬如：<strong>周星驰</strong>，<strong>刘德华</strong>，<strong>谢霆锋</strong>，<strong>张卫健</strong>，<strong>何中华</strong>，<strong>梁朝伟</strong>等等等等，就不一一缀言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>见识浅薄，故此必然难以周全。仅以所晓明星作品和人生为基点，个人喜好为腔调来絮叨。耗一日之功来敲打，权作祭奠和分享逝去的功夫片陪伴的那些青葱岁月。若有不妥处，还请见谅。</p>]]>
    
    </summary>
    
      <category term="Share" scheme="http://jeffjade.github.io/tags/Share/"/>
    
      <category term="Share" scheme="http://jeffjade.github.io/categories/Share/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类数组借用数组方法]]></title>
    <link href="http://jeffjade.github.io/2015/11/02/2015-11-02-likeArray-borrow-ArrayFun/"/>
    <id>http://jeffjade.github.io/2015/11/02/2015-11-02-likeArray-borrow-ArrayFun/</id>
    <published>2015-11-02T04:00:00.000Z</published>
    <updated>2015-11-02T07:19:11.000Z</updated>
    <content type="html"><![CDATA[<p>于JavaScript如何将对象转化为数组对象，其用法写法已经很常见且完善，比如JQuery中的<code>makeArray</code>函数对此的实现，也是跟大家想的差不多，只是考虑的周全些罢了,<a href="#3">看源码</a>；但对于<code>类数组借用数组方法</code>的写法，对其学习探究过程中大长了些许姿势，觉其倒是一个挺有趣问题。</p>
<a id="more"></a>
<h2 id="何为“类数组”"><strong>何为“类数组”</strong></h2><p>JavaScript中有一些看起来像却又不是数组的对象，唤作: <strong>类数组</strong>。一个类数组对象：</p>
<ul>
<li>具有：指向对象元素的数字(非负整数)索引下标以及length属性告诉我们对象的元素个数</li>
<li>不具有：诸如 push forEach 以及 indexOf 等数组对象具有的方法</li>
</ul>
<p>javascript中常见的类数组有arguments对象,DOM方法或者JQuery方法的返回结果。<br>比如<code>document.getElementsByTagName()</code>。实际上，只要有length属性，且它的属性值为number类型即可。</p>
<p><strong>类数组示例：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>,<span class="string">'2'</span>:<span class="string">'love'</span>,<span class="string">'4'</span>:<span class="string">'jeffjade'</span>,length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a,<span class="string">'+'</span>);<span class="comment">//'+gg+love++jeffjade'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>非类数组示例：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123;<span class="string">'1'</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>没有length属性，所以就不是类数组。</p>
<h2 id="借用数组方法"><strong>借用数组方法</strong></h2><h3 id="法一：用数组什么方法，借助call或者apply即可，比如；"><strong>法一</strong>：用数组什么方法，借助call或者apply即可，比如；</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//OutPut: [1,2,3,4]  //Chrome Console</span></span><br><span class="line">    <span class="comment">//OutPut: / &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125; //SublimeText NodeJs</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="法二：函数反柯里化(function_uncurrying)"><strong>法二：</strong>函数反柯里化(function uncurrying)</h3><p><code>Array.prototype</code>上的方法原本只能用来操作array对象。但用<code>call</code> <code>apply</code> 可以把任意对象当做this传入某个方法，如此一来，方法中用到的this的地方就不再局限于原来规定的对象，而是加以泛华并且得到更广的适用性。</p>
<p>但是直接使用这样使用，多少是有些繁琐的。如需使用Array的shift方法，就还得写Like This：<code>Array.prototype.shift.call(arguments);</code>;如能将泛化this的过程提取出来，岂不方便很多？并且代码还能复用。</p>
<p><strong>uncurrying</strong>的话题来自JavaScript之父Brendan Eich在2011年发表的一篇Twitter。<br>以下代码是uncurrying的实现方式之一<strong>@<a href="#1">注解^</a></strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其作用如是：在类数组对象借用<code>Array.prototype</code>方法之前，先把Array.prototype.push.call这句代码转换为一个通用的<code>push</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.uncurrying();</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	push(<span class="built_in">arguments</span> , <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">//OutPut: [1,2,3,4]  //Chrome Console</span></span><br><span class="line">    <span class="comment">//OutPut: / &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125; //SublimeText NodeJs</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>uncurrying</code>方式，使得Array.prototype.push.call变成了一个通用的push函数，且其函数的作用也不再仅仅局限于只能操作array对象。于使用者而言，也显得更加简洁和意图明了。</p>
<p>幸甚，还可以一次性地将Array.prototype上的方法“复制”到array对象上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="string">'push'</span>, <span class="string">'shift'</span>, <span class="string">'forEach'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn ; fn = ary[i++];) &#123;</span><br><span class="line">	<span class="built_in">Array</span>[ fn ] = <span class="built_in">Array</span>.prototype[ fn ].uncurrying();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="string">"length"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">"0"</span>:<span class="number">1</span>,</span><br><span class="line">	<span class="string">"1"</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.push(obj, <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.length);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Object &#123;0: 1, 1: 2, 2: 3, length: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> first = <span class="built_in">Array</span>.shift(obj);</span><br><span class="line"><span class="built_in">console</span>.log(first);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);    <span class="comment">//Object &#123;0: 2, 1: 3, length: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.forEach(obj , <span class="function"><span class="keyword">function</span><span class="params">(i , n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);  <span class="comment">// 分别输出 2 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(n);  <span class="comment">// 分别输出 0 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当然，<code>function uncurrying</code>还有其他实现方式<strong>@<a href="#2">注解^</a></strong>，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// var obj = Array.prototype.shift.call(arguments);</span></span><br><span class="line">        <span class="comment">// return self.apply(obj, arguments);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="代码稍做分析"><strong>代码稍做分析</strong></h4><p>就取Array.prototype.push.uncurrying()这句代码来分析下，<code>uncurrying</code>的时候发生了什么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// self此时是Array.prototype.push</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// var obj = Array.prototype.shift.call(arguments); </span></span><br><span class="line">        <span class="comment">// return self.apply(obj, arguments);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>); <span class="comment">//法2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.uncurrying();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"length"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">"0"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">push(obj , <span class="number">2</span>); <span class="comment">//uncurrying函数接收到的arguments即'obj ,2'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Outpt: &#123;0:1, 1:2,length:2&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1">function uncurrying 法一：</h4>

<p>用法一，因为<code>Array.prototype.shift</code>的截断，arguments,即剩下[2]了；相当于如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.prototype.push.apply(obj, <span class="built_in">arguments</span>);<span class="comment">//此时arguments=2；</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2">function uncurrying 法二：</h4>

<p>实现方式二，很有趣;可参见@<a href="http://stackoverflow.com/questions/13004342/call-and-apply-in-javascript" target="_blank" rel="external">stackoverflow透彻回答</a>；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//self此时是Array.prototype.push</span></span><br></pre></td></tr></table></figure></p>
<p>大体如此：<code>Function.prototype.call</code>是一个函数；<code>call</code>的this指向<code>Function.prototype</code>;使用<code>apply</code>改变了this的指向到<code>Array.prototype.push</code>;<code>arguments</code> 就被给传了call。原文如下：</p>
<blockquote>
<ol>
<li><code>Function.prototype.call</code> is a function.</li>
<li>The <code>this</code> pointer of <code>call</code> points to <code>Function.prototype</code>.</li>
<li>We use <code>apply</code> to change the <code>this</code> pointer of <code>call</code> to <code>Array.prototype.push</code>.</li>
<li><code>arguments</code> is applied (not passed as a parameter) to call.<blockquote>
<p>The advantage of this is that we’re creating a <strong><a href="http://stackoverflow.com/questions/7459769/whats-the-purpose-of-using-function-call-apply-in-javascript" target="_blank" rel="external">fast unbound wrapper</a></strong> for <code>push</code> in a single line.</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>继续看该Answer，其文提到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a>;而<code>bind</code>~绑定函数，会以创建它是传入bind()方法的第一个参数作为<code>this</code>，传入bind()方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>按照bind的功能，其实在这里bind就可以替代apply， 从而可以有这种写法了咯;而这个bind”听起来”怎么那么像<code>call</code>呢？后面那个方法不过就是改变下前面<code>call</code>的this的指向，所以<code>apply</code>替换<code>call</code>也没什么不可以的嘛，测试一下：果然可以！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return Function.prototype.call.apply(self, arguments); </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.bind(self, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// return Function.prototype.call.call(self, arguments);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只是，这样用的话就得为考虑浏览器的兼容性而写些Shim了.如原回答所述：</p>
<blockquote>
<p>A better way to create fast unbound wrappers is as follows (note that it may not work in some older browsers, but you don’t really need to worry about that now - you may always use a <strong><em>shim</em></strong> for browsers which don’t support <strong>bind</strong>):</p>
</blockquote>
<hr>
<p>@JQuery的v2.1.4版本对makeArray方法实现源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// results is for internal usage only</span></span><br><span class="line">	makeArray: <span class="function"><span class="keyword">function</span><span class="params">( arr, results )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> ret = results || [];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( arr != <span class="literal">null</span> ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( isArraylike( <span class="built_in">Object</span>(arr) ) ) &#123;</span><br><span class="line">				jQuery.merge( ret,</span><br><span class="line">					<span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?</span><br><span class="line">					[ arr ] : arr</span><br><span class="line">				);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				push.call( ret, arr );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	merge: <span class="function"><span class="keyword">function</span><span class="params">( first, second )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> len = +second.length,</span><br><span class="line">			j = <span class="number">0</span>,</span><br><span class="line">			i = first.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ( ; j &lt; len; j++ ) &#123;</span><br><span class="line">			first[ i++ ] = second[ j ];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		first.length = i;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>isArraylike()</code>代码实现可以参见<a href="http://www.jeffjade.com/2015/09/06/2015-09-06-ios8-safari-jitbug-record/" target="_blank" rel="external">这里</a>。</p>
<p><strong>参考出处</strong>：@曾探 所著的《JavaScript设计模式与开发实践》第三章~高阶函数.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>于JavaScript如何将对象转化为数组对象，其用法写法已经很常见且完善，比如JQuery中的<code>makeArray</code>函数对此的实现，也是跟大家想的差不多，只是考虑的周全些罢了,<a href="#3">看源码</a>；但对于<code>类数组借用数组方法</code>的写法，对其学习探究过程中大长了些许姿势，觉其倒是一个挺有趣问题。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客引入漂亮字体二三事]]></title>
    <link href="http://jeffjade.github.io/2015/10/28/2015-10-28-css3-webfont/"/>
    <id>http://jeffjade.github.io/2015/10/28/2015-10-28-css3-webfont/</id>
    <published>2015-10-28T13:00:00.000Z</published>
    <updated>2015-11-16T09:09:59.000Z</updated>
    <content type="html"><![CDATA[<p>最近兴致上来，就想更换了那Blog标题字体(汉字的)；网上搜索了一番，发现<code>蘇新詩柳繁體</code>这款甚合我心；然后就着手搞将了起来，分分钟也算是替换了；但，这仅仅是此次折腾的开始；这就细细道来作为学习笔记记载。</p>
<p><img src="http://www.jeffjade.com/img/toss/blogTitleStyle.png" alt=""></p>
<a id="more"></a>
<h2 id="CSS3_@font-face"><strong>CSS3 @font-face</strong></h2><p>当然要使用自定义字体，就得借助下@font-face：CSS3中的一个模块，他主要是把自己定义的Web字体嵌入到你的网页中；@font-face的语法规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;</span><br><span class="line">     <span class="rule"><span class="attribute">font-family</span>:<span class="value"> &lt;YourWebFontName&gt;</span></span>;</span><br><span class="line">     <span class="rule"><span class="attribute">src</span>:<span class="value"> &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*</span></span>;</span><br><span class="line">     <span class="rule">[<span class="attribute">font-weight</span>:<span class="value"> &lt;weight&gt;]</span></span>;</span><br><span class="line">     <span class="rule">[<span class="attribute">font-style</span>:<span class="value"> &lt;style&gt;]</span></span>;</span><br><span class="line">   <span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>其取值说明：</strong></p>
<ol>
<li><p>YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”</p>
</li>
<li><p>source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；</p>
</li>
<li><p>format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</p>
</li>
<li><p>weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</p>
</li>
</ol>
<p>在@font-face网络字体技术之前，浏览器显示网页上文字使用的字体只能限制在电脑里已经安装的几款字体里。而且每个人的电脑里安装的字体是因人而异的。@font-face的作用是从网上下载并使用自定义字体，使页面显示字体不依赖用户的操作系统字体环境。</p>
<p>好吧，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的。使用CSS3自定义字体的时候，为了兼容所有浏览器，服务器需要输出4种格式的字体，分别是eot、svg、ttf和woff。所以，若要尽量更全的支持不同浏览器，那么这里就得这样搞了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-family</span>:<span class="value"> ‘MyFontFamily’</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(‘myfont-webfont.eot?#iefix’) <span class="function">format</span>(‘embedded-opentype’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.woff’) <span class="function">format</span>(‘woff’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.ttf’)  <span class="function">format</span>(‘truetype’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.svg#svgFontName’) <span class="function">format</span>(‘svg’)</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用@font-face只是申明&amp;定义了一种字体；使用时还是得根据<em>font-family</em>特性加入些默认字体以留后路。即便如此，之后也会有些问题。W3C中描述如下：</p>
<blockquote>
<p><strong>font-family</strong>： <strong>规定元素的字体系列</strong>。可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。<br><strong>注意</strong>：使用某种特定的字体系列（Geneva）完全取决于用户机器上该字体系列是否可用；这个属性没有指示任何字体下载。因此，强烈推荐使用一个通用字体系列名作为后路。</p>
</blockquote>
<h2 id="网络字体(Web_font)文件格式"><strong>网络字体(Web font)文件格式</strong></h2><p><strong>WOFF</strong>：Web Open Font Format<br>这种字体格式专门用于网上，由Mozilla联合其它几大组织共同开发。WOFF字体通常比其它字体加载的要快些，因为使用了OpenType (OTF)和TrueType (TTF)字体里的存储结构和压缩算法。这种字体格式还可以加入元信息和授权信息。这种字体格式有君临天下的趋势，因为所有的现代浏览器都开始支持这种字体格式。</p>
<p>支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p>
<p><strong>SVG / SVGZ</strong>：Scalable Vector Graphics (Font).<br>SVG是一种用矢量图格式改进的字体格式，体积上比矢量图更小，适合在手机设备上使用。只有iPhone上的Safari(4.1)之前的版本支持它。目前火狐、IE都不支持SVG字体格式。火狐推迟对SVG字体的支持，重点放在WOFF格式上。SVGZ是压缩版的SVG。</p>
<p>支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p>
<p><strong>OTF / TTF</strong>：OpenType Font 和 TrueTypeFont。<br>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化。部分的因为这种格式容易被复制(非法的)，这才催生了WOFF字体格式。然而，OpenType有很多独特的地方，受到很多设计者的喜爱。</p>
<p>【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p>
<p><strong>EOT</strong>：Embedded Open Type。<br>这是微软创造的字体格式(是微软在15年前发明了网络字体@font-face)。这种格式只在IE6/IE8里使用。</p>
<p>.woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本。即：最起码要支持下这种格式吧。而网上下载的只有.ttf;所以就开始了字体格式转换。</p>
<h2 id="获取@font-face所需字体格式"><strong>获取@font-face所需字体格式</strong></h2><p>这个阶段折腾的老久了。毕竟是汉字的，网络上搜索的一些在线工具尝试了不少，很好工作的却也不多。<br>最后在这个网站<a href="https://onlinefontconverter.com/" target="_blank" rel="external">https://onlinefontconverter.com/</a>,得到了.woff 和 .svg格式的转换。<a href="http://www.jucelin.cn/archiver/view.asp?id=153" target="_blank" rel="external">Here</a>有介绍。</p>
<p>这里插说一段，在即将放弃的时候，发现了这个网站<a href="http://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="external">http://www.fontsquirrel.com/tools/webfont-generator</a>;国外的人士，做事就是认真，一键上传我的.tff格式的字体，它就可以帮助生成对应的4种格式外加.woff2;并且给出CSS以及对应的Demo实例(使用的是 <strong>OPTIMAL</strong>模式)。而且文件还相当的小（5种格式字体加起来就有不到150KB）。惊喜之余，不太相信，一经测试，果然，将汉字给过滤掉了。使<strong>用BASIC模式</strong>确实可以不破坏内容的生成各种格式字体，但难免的，也很大(.woff格式3528KB)。不过，对于英文的转换，还是相当可取的。如何使用?可<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">ClickHere</a>查看。</p>
<p>搞到此处，于大部分浏览器，渲染出<code>蘇新詩柳繁體</code>的标题，是没问题了。即便在Chrome浏览器上一开始是字体未显示，到被默认字体替代了，加载完毕后才重新以<code>蘇新詩柳繁體</code>渲染出来；而Safari则是，从不显示直到加载完毕才渲染出来。手机上能够渲染出来需要的时间就更长了(Android由空白到请求完成后渲染)。(<em>@ο@</em>) 哇～，如此体验着实好*啊。<br>导致这种现象，必然是各大浏览器渲染时存在的差异所致；@w3ctech<a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a>一文中有过详尽的叙述：</p>
<blockquote>
<p>A. 如果请求字体还不可用，IE 会立即使用后备字体呈现，并在字体下载完成之后马上重新呈现；<br>B. Firefox 和 Chrome 35+ 会首先下载3秒钟的字体，如果超过3秒钟后，会使用后备字体渲染网页，等到指定字体下载完成后再重新渲染网页；<br>C. Safari 和 Chrome 35之前的版本，会等到指定字体下载完成后再渲染网页（PS：就是不会使用后备字体）。</p>
<blockquote>
<p><strong>注：</strong>以上说明中没有表示IE的版本以及Safari的版本号，所以需要自己测试才能算正确。<br>因此，如果网络连接缓慢，在大多数浏览器中将延迟超过3秒的文本渲染。在最坏的情况下，如果你的字体加载带有时间限制（由于一些连接很慢的移动设备），Safari 用户将不会再展示文本，剩下一个空白网页。如果网页请求超时，最终将只会呈现一个空白网页。</p>
</blockquote>
</blockquote>
<p>毕竟用的是较全汉字繁体： .ttf格式5735KB;.woff格式3534KB,.svg格式竟然11622KB,有点醉了，555。根据@张鑫旭这篇<a href="http://www.zhangxinxu.com/wordpress/2011/11/fontforge%e8%87%aa%e5%ae%9a%e4%b9%89%e6%89%8b%e6%9c%ba%e5%ad%97%e4%bd%93/" target="_blank" rel="external">fontforge制作自定义字体及在手机上应用举例</a>文中提到的，可以采取软件(Eg:fontforge)提取出自己想要的部分,从而减小字体文件的大小，来增强体验；但是我这边是汉字，折腾起来不容易啊，555。如此，就牵扯到了：网络字体(Web font)的效率问题了。</p>
<h2 id="网络字体(Web_font)的效率"><strong>网络字体(Web font)的效率</strong></h2><p>字体文件的体积可能非常的大(尤其是对于汉字)，而且需要额外的HTTP连接，这些都会降低网站页面的加载速度。所以，在使用网络字体@font-face前，根据网络上的说法：需要清楚它的利与弊，判断网络字体是否真的有必要用在你的网站页面上。</p>
<blockquote>
<p>如果你决定使用个性化自定义字体，可以采用一个非常灵活的方法，就是只加载尽量少的字体字符数和尽量少的字体风格(粗体/斜体)。例如，如果你使用谷歌字体，你可以只加载指定的字体风格组合：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(http://fonts.googleapis.com/css?family=Averia+Sans+Libre:<span class="number">400</span>,<span class="number">300</span>italic,<span class="number">700</span>)</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>以下是@<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">Airen的博客</a>对于使用@font-face的写于提醒：</p>
<blockquote>
<ol>
<li>如果你的项目中是英文网站，而且项目中的Logo，Tags等应用到较多的这种特殊字体效果，我建议你不要使用图片效果，而使用@font-face，但是你是中文网站，我觉得还是使用图片比较合适，因为加载英文字体和图片没有多大区别，但是你加载中文字体，那就不一样了，因为中文字体太大了，这样会影响到项目的某些性能的优化；</li>
<li>致命的错误，你在@font-face中定义时，文件路径没有载对；</li>
<li>你只定义了@font-face，但并没有应用到你的项目中的DOM元素上；</li>
</ol>
</blockquote>
<p>就目前我的需求而言，Blog用到这字体，仅是在于标题那5个汉字而已。如不能优化至流畅之境，倒不如采用加载经过Ps处理的图片呢;毕竟之于体验和炫酷间抉择，还是前者更为重要些。然，还是得为此探究一番，万一已经好的解决办法了呢？一查，果真有!喜不自胜。</p>
<h2 id="base64编码字体，自定义你的网站字体！"><strong>base64编码字体，自定义你的网站字体！</strong></h2><p>CSS3给我们带来了@font-face,网页中可以展现的字体就不局限于电脑中已安装的几款字体。@font-face的作用是从网上下载并使用自定义字体，使页面显示字体不依赖用户的操作系统字体环境。</p>
<p>然而：字体文件的体积一般都比较大，而且需要额外的http请求连接，而且需要兼容多种浏览器的话，往往需要三四个或者更多格式的字体文件。尤其是汉字字体文件；于是乎就有了，WebFont (Web Open Font Format)这个技术，极大滴有针对性的压缩了字体文件的体积，压缩了体积就解决了个大问题，很实用。WebFont的字体转换成base64编码，直接放在样式表里面，哇哦，完美。要实现这个，首先我们得<strong>生成下载需要的字体</strong>;毕竟，整个汉字库辣(那)么大，即便生成base64，其体积也不小哇。</p>
<h3 id="生成下载需要的字体"><strong>生成下载需要的字体</strong></h3><p>先设置我们要使用的文字，使用WebFont，推荐阿里妈妈WebFont平台<a href="http://www.iconfont.cn/webfont/#!/webfont/index" target="_blank" rel="external">http://www.iconfont.cn/webfont/#!/webfont/index</a>和有字库<a href="http://www.youziku.com/" target="_blank" rel="external">http://www.youziku.com/</a>，使用简单粗暴，输入你要的文字，下载就完了，代码都给你生成好了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;<span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'webfont'</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.eot'</span>)</span></span>; <span class="comment">/* IE9*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.eot?#iefix'</span>) <span class="function">format</span>(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.woff'</span>) <span class="function">format</span>(<span class="string">'woff'</span>), <span class="comment">/* chrome、firefox */</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.ttf'</span>) <span class="function">format</span>(<span class="string">'truetype'</span>), <span class="comment">/* chrome、firefox、opera、Safari, Android, iOS 4.2+*/</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.svg#NotoSansHans-Black'</span>) <span class="function">format</span>(<span class="string">'svg'</span>)</span></span>; <span class="comment">/* iOS 4.1- */</span></span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>ctrl+c ctrl+v 就解决了需求，在需要的地方使用即可（这里可以直接使用它给你生成的在线字体woff格式等文件【只有你输入的那些汉字喔】），兼容至BT的IE6，简直碉堡。但，好吧，世间没有那么完美的事儿喔。<code>阿里妈妈webfont</code>平台只有思源系的5种不同字体而已，哭晕，没有我倾爱的<code>蘇新詩柳</code>啊。</p>
<h3 id="base64编码字体"><strong>base64编码字体</strong></h3><p>经过譬如上面操作，得到字体文件之后，即可运用一些软件（譬如<a href="http://www.giftofspeed.com/base64-encoder/" target="_blank" rel="external">http://www.giftofspeed.com/base64-encoder/</a>编码之，使之生成base64编码string。<strong>使用：</strong>把处理好了的base64编码放在下面代码中(直接替代xxxxx即可)，然后调用<code>webfont-base</code>这个定义好的字体，大功告成！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: 'webfont-base';</span><br><span class="line">    src: url(data:font/truetype;charset=utf-8;base64,XXXXXXXXXXXXXXXXX) format('truetype');</span><br><span class="line">    font-weight: normal;</span><br><span class="line">    font-style: normal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额，好吧，使用这个网站生成的base64也是奇葩的－－有很多空格换行，base64文件蛮大的话，就需要想点办法予以处理下才好。</p>
<p></p><p data-height="268" data-theme-id="20035" data-slug-hash="MaQOOM" data-default-tab="result" data-user="jeffjade" class="codepen">See the Pen <a href="http://codepen.io/jeffjade/pen/MaQOOM/" target="_blank" rel="external">MaQOOM</a> by jeffjade (<a href="http://codepen.io/jeffjade" target="_blank" rel="external">@jeffjade</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h3 id="字体文件加载优化"><strong>字体文件加载优化</strong></h3><p>之前已经探明，可以使用字体base64编码信息的CSS字体文件，来替代请求woff格式字体下载；但该CSS文件的大小取决于你选择的字符集合以及相关方面，也许该文件相当的大（最高可达100~300KB）。因此，使用gzip压缩以及设置强缓存的方式对于用户来说是很重要的。</p>
<p>不过幸运的是只有当你网页的浏览者第一次访问该CSS文件的时候会发出请求。由于在第一次的时候，用户本地没有该字体文件，所以浏览器就会去异步加载他们，并且存储在localStorage中。当用户的网络环境较慢的情况下，能够看到后备字体以及webfonts渲染过程，不过这些只会发生在用户第一次访问你网页的时候。大多数用户不会太在意这一细节。</p>
<p>当用户第二次网页页面的时候，浏览器将从localStorage中加载CSS文件内容，这种方式相当的快速（5~50ms）。在这种情况下用户看不到任何的闪烁，因为所有的操作将是同步进行的，这仅仅只需要几毫秒的时间。具体可参见@<a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a>一文所书。</p>
<p><strong>体验至上，优化不止，且学且究，渐探渐优。</strong></p>
<hr>
<p>写在最后，纵使有阿里妈妈这样的平台，但其所针对的汉字字体也太有限。最后还是以图片形式呈现出<code>蘇新詩柳</code>字体的标题(这里采用艺术字体在线转换<a href="http://www.qt86.com/" target="_blank" rel="external">Qt86</a>生成，可惜这个生成的仅是图片，若能成就base64编码，就太棒了。不过它所提供的字体三百余种，可谓丰富)；此处待之后有合适的法子，再继续折腾(Update: 15-11-16)。</p>
<hr>
<p>参考文章链接：<br><a href="http://www.webhek.com/font-face" target="_blank" rel="external">@font-face的用法</a><br><a href="http://guoshuang.com/css/font-face-type/" target="_blank" rel="external">Font-face 字体文件格式</a><br><a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">CSS3 @font-face</a><br><a href="http://www.lccky.com/166.html" target="_blank" rel="external">base64编码字体，自定义你的网站字体！</a><br><a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近兴致上来，就想更换了那Blog标题字体(汉字的)；网上搜索了一番，发现<code>蘇新詩柳繁體</code>这款甚合我心；然后就着手搞将了起来，分分钟也算是替换了；但，这仅仅是此次折腾的开始；这就细细道来作为学习笔记记载。</p>
<p><img src="http://www.jeffjade.com/img/toss/blogTitleStyle.png" alt=""></p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://jeffjade.github.io/tags/CSS/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows下效率必备软件]]></title>
    <link href="http://jeffjade.github.io/2015/10/19/2015-10-18-Efficacious-win-software/"/>
    <id>http://jeffjade.github.io/2015/10/19/2015-10-18-Efficacious-win-software/</id>
    <published>2015-10-19T10:00:00.000Z</published>
    <updated>2015-11-02T07:06:22.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！重而说三。</p>
<a id="more"></a>
<p><strong>AutoHotKey</strong>: 神器！神器！神器！当然也得看使用者咯(<em>^__^</em>) 嘻嘻……</p>
<p><strong>Listary</strong>： 本地搜索<strong>神器</strong>，当然还有别的作用，More&amp;More。</p>
<p><strong>Launchy</strong> : 快速启动安装的应用程序，老而弥坚，有丝Mac下Spotlight之风；</p>
<p><strong>Chrome</strong>: Web世界里的神，的神，神。偏爱ing；</p>
<p><strong>SublimeText3</strong>： 编码垒字的神器，还能览图/文件对比/…,偏爱ing；</p>
<p><strong>Picasa3</strong>: 图片查看器中的佼佼者，偏爱ing。姑姑出品，必属精品！</p>
<p><strong>Clover</strong>： 在Win下必备，谁让Win资源管理器太…QT，TotalCommand太重(⊙o⊙)…</p>
<p><strong>Everything</strong>： 本来必备神器，无奈我移情别恋了—Listary。不过是不会忘了你。</p>
<p><strong>Foxmail</strong>： 对比体验不多，不做评判，必备；反正不用win自带的。</p>
<p><strong>Evernote</strong>: 纪录/收藏你想保存的文｜图｜网页;<strong>为知笔记</strong>～功能同丰满,身材更骨感😄。</p>
<p><strong>Beyond Compare</strong> : 文件比较器; 此款为所接触中最佳。</p>
<p><strong><a href="https://github.com/cmderdev/cmder/releases" title="CmderDownAdress" target="_blank" rel="external">Cmder</a></strong>:  windows下cmd的替换工具,支持PowerShell;同比还有PowerShell，<a href="https://github.com/Maximus5/ConEmu" title="ConEmuDownAdress" target="_blank" rel="external">ConEmu</a> 等。</p>
<p><strong><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">作业部落客户端</a></strong>:开启卓越写作之旅,支持全平台＋离线使用，一键发布文稿，社交化批注。身材苗条，面容姣好，免费Markdown书写平台的魅力战斗机。 </p>
<p><strong>夜神模拟器</strong>: 经历了<code>BlueStacks</code>,<code>海马</code>，一遇这<code>夜神</code>,认你乃最佳！</p>
<p><strong>网易云音乐</strong>: 初遇<code>QQ音乐</code>,处过<code>天天动听</code>,恋过<code>酷狗</code>，上过<code>酷我</code>，一夜情过<code>千千静听</code>,移情过<code>虾米</code>，和<code>豆瓣FM</code>好过，同<code>百度随心听</code>约过,最后，发现音乐的世界,还得是你～<strong>网易云音乐</strong>。</p>
<p><strong><a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/" target="_blank" rel="external">更多关于效率工具文章</a></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！重而说三。</p>]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vimium~让您的Chrome起飞]]></title>
    <link href="http://jeffjade.github.io/2015/10/19/2015-10-18-chrome-vimium/"/>
    <id>http://jeffjade.github.io/2015/10/19/2015-10-18-chrome-vimium/</id>
    <published>2015-10-19T03:00:00.000Z</published>
    <updated>2015-10-19T10:26:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>工欲善其事，必先利其器！</strong>撸起Vimium,我的Chrome就这么起飞了。</p>
<a id="more"></a>
<p>如今PC和Mac端安装的Chrome插件(偏前端)：<br><strong>Vimium</strong>：黑客级别的Chrome插件，此文主记载的<strong>主角~(The Hacker’s Browser )</strong>；<br><strong>ABP</strong>： 有她在，WEB的世界就可以清静点了.<br><strong>infinity</strong>：没有最好，只有更好，此款新标签页，如今最爱。<br><strong>crxMouse</strong>: 如果用鼠标操作Chrome,必备=充分发掘鼠标的所有操作。<br><strong>JASN-handle</strong>：Json解析，所用之中综合体验最优者；<br><strong>OK记</strong>： 一键记录你想记载的，体验一流！<br><strong>Pocket</strong>: 轻松保存文章，视频等供以后查看。<br><strong>QR码生成器</strong>： PC阅读-URL转移手机的桥梁，用的不多。<br><strong>WEB前端助手</strong>： 功能虽不少，用的却也少。<br><strong>Website Ip Option</strong>：获取了每个网页Ip显示于屏幕下方。<br><strong>Web Design Tester</strong>：Installed,web Devolop，暂时用的不多。<br><strong>Web Developer</strong>：Installed,web Devolop，暂时用的不多。<br><strong>CssViewer</strong>：Installed,web Devolop，暂时用的不多。<br><strong>PerfectPixel</strong>+<strong>EmmetLiveStyle</strong>: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。</p>
<p>更多插件请参见知乎<a href="http://www.zhihu.com/question/19594682" target="_blank" rel="external">你极力推荐的Chrome 扩展有哪些？</a>问题的各种回复。</p>
<hr>
<p>学起(了解几个快捷键即可)And撸起<strong>Vimium</strong>,想黑客一般在Chrome上飞起。<br><strong>Vimium常用快捷键</strong>(注：区分大小写)<br><strong>j</strong>, <c-e> : 向下移动 Scroll down<br><strong>k</strong>, <c-y> : 向上移动Scroll upi<br><strong>h</strong> : 左移 Scroll left<br><strong>l</strong> : 右移 Scroll right</c-y></c-e></p>
<p><strong>H</strong>：回到上一个历史页面<br><strong>L</strong>：回到下一个历史页面<br><strong>J</strong>：跳到左边标签页<br><strong>K</strong>：跳到右边标签页<br><strong>t</strong>：创建新的标签页（ctrl+t）</p>
<p><strong>d</strong> : 向下移动一个页面 Scroll a page down<br><strong>u</strong> : 向上移动一个页面 Scroll a page up</p>
<p><strong>gg</strong> : 移到页面顶部 Scroll to the top of the page<br><strong>G</strong> : 移到页面底部 Scroll to the bottom of the page</p>
<p><strong>x</strong>：关闭当前标签页<br><strong>X</strong>：恢复关闭的标签页</p>
<p><strong>r</strong> : 刷新 Reload the page<br><strong>gs</strong> : 查看网页源码 View page source<br><strong>yy</strong> : copy当前页面url Copy the current URL to the clipboard<br><strong>yf</strong> : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard<br><strong>yt</strong> : 创建当前页面的一个副本(copy当前路径在新Tab中打开)-Duplicate current tab<br><strong>YT</strong> : 罗列出当前所有Tab页(并提供索引)，可任你选择性跳转，帅；</p>
<p><strong>p</strong> : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab<br><strong>P</strong> : 在新的标签页中打开剪切板中的链接Open the clipboard’s URL in a new tab</p>
<p><strong>gu</strong> : Go up the URL hierarchy（例如，URL为<a href="http://blog.net/article/8021689" target="_blank" rel="external">http://blog.net/article/8021689</a> ，按下gu后，转到<a href="http://blog.net/article/，回到该网站该访问者主页）" target="_blank" rel="external">http://blog.net/article/，回到该网站该访问者主页）</a><br><strong>gU</strong> : Go to root of current URL hierarchy (类似gu，回到根URL页 <a href="http://blog.net" target="_blank" rel="external">http://blog.net</a>)</p>
<hr>
<p><strong>f</strong> : 在当前标签页中打开链接 Open a link in the current tab<br><strong>F</strong> : 在新标签页中打开链接 Open a link in a new tab</p>
<p>YES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再<strong>输入相应的编码完成点击</strong>或者复制连接操作，包含常见的a标签，button标签，input标签中type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。<br><img src="http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png" alt="Vimium-F-Link"></p>
<hr>
<p><strong>o</strong> : 在当前页面中打开URL，书签和历史记录 Open URL, bookmark, or history entry<br><strong>O</strong> : 在新标签页中打开URL，书签和历史记录Open URL, bookmark, history entry, in a new tab<br><strong>T</strong> : 搜索打开的标签页 Search through your open tabs</p>
<p><strong>b</strong> : 打开书签 Open a bookmark<br><strong>B</strong> : 在新标签中打开书签 Open a bookmark in a new tab<br>在命令行模式，按下b(B)，可以对标签进行检索，检索结果通过tab键进行选择，回车即可打开标签。</p>
<p><img src="http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png" alt="Vimium-bB"></p>
<p>/：查找（ctrl+f）<br><strong>i</strong> : 进入输入模式 Enter insert mode<br><strong>esc</strong>：退出</p>
<hr>
<p>还有些还不怎么常用的，比如：<br><strong>zH</strong> : Scroll all the way to the left<br><strong>zL</strong> : Scroll all the way to the right<br><strong>m</strong> : Create a new mark</p>
<p>最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可Close之，如下图：<br><img src="http://images.cnitblog.com/blog/431064/201403/141813348554340.png" alt="vimium-help"></p>
<p>切记(to myself)：<strong>熟能生巧，至巧了，即可夺天之工</strong>。</p>
<p>未完待续…</p>
<p>参考文章链接：<br><a href="http://lin.xiaogang.me/?p=315" target="_blank" rel="external">chrome的vim模式</a><br><a href="http://blog.csdn.net/xiajian2010/article/details/23931273" target="_blank" rel="external">关于vim化浏览器</a></p>
<p>推荐阅读(对于有待更熟悉Win下快捷操作的同志)：<br><a href="http://www.cnblogs.com/wayou/p/shortcuts.html" target="_blank" rel="external">没有鼠标的日子多亏了我精湛的手操，各种快捷键分享</a><br><a href="http://www.jianshu.com/p/3cb5c6f2421c" target="_blank" rel="external">如何优雅地使用Sublime Text3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>工欲善其事，必先利其器！</strong>撸起Vimium,我的Chrome就这么起飞了。</p>]]>
    
    </summary>
    
      <category term="Chrome" scheme="http://jeffjade.github.io/tags/Chrome/"/>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cleaver快速制作网页PPT]]></title>
    <link href="http://jeffjade.github.io/2015/10/15/2015-10-16-cleaver-make-ppt/"/>
    <id>http://jeffjade.github.io/2015/10/15/2015-10-16-cleaver-make-ppt/</id>
    <published>2015-10-15T03:50:00.000Z</published>
    <updated>2015-10-19T10:12:27.000Z</updated>
    <content type="html"><![CDATA[<p>如今互联网时代，以浏览器作为入口，已经有越来越多的桌面应用被web应用所取代。微软最赚钱的Office办公软件，也正在被免费的web应用所吞噬。如今即便薄学如我就已然知晓<code>reveal.js</code> <code>impress.js</code>等各种轮子来制作体验优良的网页PPT。今天就来尝试下这Node.js的轮子<code>Cleaver</code>来制作网页PPT。</p>
<p>Cleaver基于HTML5，用最短的时间做出超炫幻灯片。你还会坚持PowerPoint吗？</p>
<a id="more"></a>
<h3 id="Cleaver介绍"><strong>Cleaver介绍</strong></h3><p>如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。<br>Cleaver的官方发布页：<a href="http://jdan.github.io/cleaver/" target="_blank" rel="external">http://jdan.github.io/cleaver/</a>；<br>参考文章:<a href="http://blog.fens.me/nodejs-slide-cleaver/" target="_blank" rel="external">30秒制作幻灯片 Cleaver</a>。</p>
<h3 id="Cleaver安装"><strong>Cleaver安装</strong></h3><p>系统环境(据悉：支持Linux 和 Mac; cleaver不支持win系统)<br>Linux: Ubuntu 12.04 LTS 64bit<br>node: v0.6.12<br>npm: 1.1.4<br>通过nodejs安装Cleaver<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#23616;&#37096;&#23433;&#35013;Cleaver&#10;~ mkdir nodejs-cleaver &#38;&#38; cd nodejs-cleaver&#10;~ sudo npm install cleaver&#10;&#10;//&#20840;&#23616;&#23433;&#35013;Cleaver&#10;~ sudo npm install cleaver -g</span><br></pre></td></tr></table></figure></p>
<h3 id="Cleaver基本使用"><strong>Cleaver基本使用</strong></h3><p>执行cleaver命令，解析一个markdown文件，会自动生成HTMl文档，欧耶,算是Pandoc的部分功能深入了;</p>
<p>用cleaver自带的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#22914;&#26159;&#23616;&#37096;&#23433;&#35013;&#65292;&#36816;&#34892;&#19979;&#38754;&#19968;&#21477;&#23601;&#22909;&#10;cleaver node_modules/cleaver/examples/basic.md&#10;&#10;//&#22914;&#26159;&#20840;&#23616;&#23433;&#35013;&#65292;&#35831;&#36305;&#36215;Like this&#65306;&#10;cleaver  /usr/local/lib/node_modules/cleaver/examples/basic.md</span><br></pre></td></tr></table></figure></p>
<h3 id="Cleaver配置选项option"><strong>Cleaver配置选项option</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Basic Example  #HTML&#30340;&#26631;&#39064;&#21517;&#10;author:               #&#20316;&#32773;&#20449;&#24687;,&#22312;&#26368;&#21518;&#19968;&#39029;&#26174;&#31034;&#10;  name: Jordan Scales&#10;  twitter: jdan&#10;  url: http://jeffjade.com&#10;output: basic.html</span><br></pre></td></tr></table></figure>
<p>除此之外还有其他额外设置，譬如：</p>
<ul>
<li>theme: 皮肤(theme: jdan/cleaver-retro)</li>
<li>style: css样式表(style: css/main.css)</li>
<li>output: 生成的HTML文件名(output: basic.html)</li>
<li>controls: 控制按钮(controls: true)</li>
<li>progress: 顶部显示进程条(progress: true)</li>
<li>agenda: 生成一个目录页(progress: false)</li>
<li>encoding: 文档的字符编码(encoding: utf-8)</li>
<li>template: 设置每张slide的模板(template: template/slide.mustache)</li>
<li>layout: 设置HTML模板(template: template/layout.mustache)</li>
</ul>
<h3 id="Cleaver的正文内容:"><strong>Cleaver的正文内容:</strong></h3><p>Cleaver仅支持Markdown语法的，通过Markdown构建网页内容，Markdown官方网站：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a></p>
<p>需要注意的是，Cleaver以” — “(两个中横线)做为分页的标志，其他语法都遵循Markdown规则。</p>
<p>MS Office PowerPoint 正在被渐行渐远。。。</p>
<h3 id="写在最后"><strong>写在最后</strong></h3><p>相比于之下，<code>impress.js</code>, <code>reveal.js</code>以及Cleaver三者各有特色吧；在唯快不破的理论下，Cleaver自然占据了无与伦比的优势，只是像动画，样式等比于impress是一个短板。并且，在写此文的时候欲以Cleaver来呈现的，不过总是报出下面这样的问题(Mac OS X Yosemite)：</p>
<blockquote>
<p>!! Cannot read property ‘compiled’ of undefined<br>Please report this to <a href="https://github.com/chjj/marked" target="_blank" rel="external">https://github.com/chjj/marked</a>.</p>
</blockquote>
<p>花了些许时间来探究这个问题，只是现在网络上目测关于这个信息不是很多。逐一对比之下，文章的格式没什么问题。在即将放弃的时候，发现原来是标记代码的时候用了<font color="purple">```shell</font>,所造成的问题,去掉shell或者换成别的也就没有问题了。额…。</p>
<p>点击这里查看：<a href="/special/md2pptViaCleaver.html" style="font-size:1em;font-weight:blod">此文的PPT版本(Cleaver)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今互联网时代，以浏览器作为入口，已经有越来越多的桌面应用被web应用所取代。微软最赚钱的Office办公软件，也正在被免费的web应用所吞噬。如今即便薄学如我就已然知晓<code>reveal.js</code> <code>impress.js</code>等各种轮子来制作体验优良的网页PPT。今天就来尝试下这Node.js的轮子<code>Cleaver</code>来制作网页PPT。</p>
<p>Cleaver基于HTML5，用最短的时间做出超炫幻灯片。你还会坚持PowerPoint吗？</p>]]>
    
    </summary>
    
      <category term="Cleaver" scheme="http://jeffjade.github.io/tags/Cleaver/"/>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="NodeJs" scheme="http://jeffjade.github.io/tags/NodeJs/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精美动画后宫苑]]></title>
    <link href="http://jeffjade.github.io/2015/10/15/2015-10-15-nice-animation-collection/"/>
    <id>http://jeffjade.github.io/2015/10/15/2015-10-15-nice-animation-collection/</id>
    <published>2015-10-15T03:50:00.000Z</published>
    <updated>2015-10-15T10:16:25.000Z</updated>
    <content type="html"><![CDATA[<p>对于觉得美的事物，向来都怀有收藏之癖。迷恋精美网页动画已久，只是未能遇见娇藏她的“铜雀台”。直到一见钟情于她~<code>CodePen</code>站点地址：<a href="http://codepen.io/" target="_blank" rel="external">http://codepen.io/</a>。一款高效在线IDE，不仅站点是在墙内的，并且可免费使用其常用功能；并且功能体验俱佳，真是深得我心啊。至于关于CodePen可以参见：<a href="http://stoneydream.com/2015/09/19/%E4%BD%BF%E7%94%A8codepen%E5%88%86%E4%BA%AB%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81/" target="_blank" rel="external">使用codepen分享前端代码</a>和张鑫旭的<a href="http://www.zhangxinxu.com/wordpress/2012/07/codepen-jsfiddle/" target="_blank" rel="external">见多识广,CodePen项目网站简介</a>。当然，仅仅收藏之，倒无什么意义，待得空闲，须当一一深析以为己用方是正道。</p>
<a id="more"></a>
<p data-height="268" data-theme-id="0" data-slug-hash="YXQoQE" data-default-tab="result" data-user="nikrowell" class="codepen">See the Pen <a href="http://codepen.io/nikrowell/pen/YXQoQE/" target="_blank" rel="external">Scripted Heart</a> by Nik (<a href="http://codepen.io/nikrowell" target="_blank" rel="external">@nikrowell</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><br><p><script async src="http://codepen.io/assets/embed/ei.js"></script><span id="more-2017"></span></p>

<hr>
<p data-height="268" data-theme-id="20035" data-slug-hash="yYzyWQ" data-default-tab="result" data-user="natewiley" class="codepen">See the Pen <a href="http://codepen.io/natewiley/pen/yYzyWQ/" target="_blank" rel="external">Infinite Cubes CSS</a> by Nate Wiley (<a href="http://codepen.io/natewiley" target="_blank" rel="external">@natewiley</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>]]></content>
    <summary type="html">
    <![CDATA[<p>对于觉得美的事物，向来都怀有收藏之癖。迷恋精美网页动画已久，只是未能遇见娇藏她的“铜雀台”。直到一见钟情于她~<code>CodePen</code>站点地址：<a href="http://codepen.io/">http://codepen.io/</a>。一款高效在线IDE，不仅站点是在墙内的，并且可免费使用其常用功能；并且功能体验俱佳，真是深得我心啊。至于关于CodePen可以参见：<a href="http://stoneydream.com/2015/09/19/%E4%BD%BF%E7%94%A8codepen%E5%88%86%E4%BA%AB%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81/">使用codepen分享前端代码</a>和张鑫旭的<a href="http://www.zhangxinxu.com/wordpress/2012/07/codepen-jsfiddle/">见多识广,CodePen项目网站简介</a>。当然，仅仅收藏之，倒无什么意义，待得空闲，须当一一深析以为己用方是正道。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript对象length]]></title>
    <link href="http://jeffjade.github.io/2015/10/08/2015-10-08-js-object-length/"/>
    <id>http://jeffjade.github.io/2015/10/08/2015-10-08-js-object-length/</id>
    <published>2015-10-08T09:30:00.000Z</published>
    <updated>2015-10-09T07:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>前几日有在<a href="http://www.jeffjade.com/2015/09/25/2015-09-25-js-array/#" target="_blank" rel="external">Javascript数组操作</a>一文中稍提及了数组的length属性；深入一点探究，就发现JS这length确有许多难为所知的特性。这就边学边探究下这朵奇葩属性;这里边深入边记载。</p>
<a id="more"></a>
<h2 id="可变的数组length属性">可变的数组length属性</h2><p>和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">5</span>; <span class="comment">//将数组的长度减少到5，索引等于或超过5的元素被丢弃</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素已经变为"undefined"</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">10</span>; <span class="comment">//将数组长度恢复为10</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//虽然长度被恢复为10，但第9个元素却无法收回，显示"undefined"</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure>
<p>length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure>
<h2 id="JS对象的length">JS对象的length</h2><p>在JS中来判断一个对象是否为数组，是需要费点周折的。但以是否具有length属性来衡量之，显然是不合理的。length数组不是独有的，JS对象也是可以用的(当然，数组也是对象的一种～数组对象)。譬如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>, <span class="string">'2'</span>:<span class="string">'love'</span>, <span class="string">'4'</span>:<span class="string">'meimei'</span>, length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p><em>JavaScript中有一些看起来像却又不是数组的对象，唤作</em>: <strong>类数组</strong>。一个类数组对象：</p>
<ul>
<li>具有：指向对象元素的数字索引下标以及<code>length</code>属性告诉我们对象的元素个数</li>
<li>不具有：诸如 <code>push</code>  <code>forEach</code> 以及 <code>indexOf</code> 等数组对象具有的方法</li>
</ul>
<p>两个典型的类数组的例子是：DOM方法 <code>document.getElementsByClassName()</code>的返回结果（实际上许多DOM方法的返回值都是类数组）以及特殊变量 arguments [1]。例如你可以通过以下方法确定函数参数的个数：<code>arguments.length</code><br>你也可以获取单个参数值，例如 <code>arguments[0]</code>。<br>如果这些对象想使用数组的方法，就必须要用某种方式“借用”。这里的“借用”可以借助JS的call，apply方法来实现。有时候处理类数组对象的最好方法是将其转化为数组。 这项工作也可以使用通用方法来完成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>,<span class="string">'2'</span>:<span class="string">'love'</span>,<span class="string">'4'</span>:<span class="string">'meimei'</span>,length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj , <span class="string">'+'</span>); <span class="comment">//'+gg+love++meimei'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类数组判断">类数组判断</h3><p>聊起JS对象的length就有必要说下这个<strong>类数组判断</strong>。之前有在<a href="http://www.jeffjade.com/2015/09/06/2015-09-06-ios8-safari-jitbug-record/" target="_blank" rel="external">IOS 8 Safari JIT bug影响jQuery和underscore</a>记录使用Underscore在IOS机器引起的问题。而对于此问题，jQuery，Underscore方面修复的办法就是改变了<em>类数组判断</em>的判断方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//underscore 1.7.0 _.each部分代码</span></span><br><span class="line"><span class="keyword">var</span> i, length = obj.length;</span><br><span class="line"><span class="keyword">if</span> (length === +length) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比与underscore1.8.3 _.each部分代码(是采用isArrayLike来判断的)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span><span class="params">(collection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> property = <span class="function"><span class="keyword">function</span><span class="params">(key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于数组是有下标的，其下标的范围是”大于等于0并小于2^32-1的整数”，如果数字太大的话你想难为JavaScript是做不到的。因为其会自动将其转化为”字符串”。而underscore1.8.3用的MaxLength是<code>Math.pow(2, 53) - 1</code>（其值:9007199254740992）,不解😄，待探究下～</p>
<p>而《javascript权威指南》上给出的代码用来判断一个对象是否属于“类数组”。其code如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                <span class="comment">// o is not null, undefined, etc.</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp;            <span class="comment">// o is an object</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;               <span class="comment">// o.length is a finite number</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                    <span class="comment">// o.length is non-negative</span></span><br><span class="line">        o.length===<span class="built_in">Math</span>.floor(o.length) &amp;&amp;  <span class="comment">// o.length is an integer</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>)              <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// Then o is array-like</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                       <span class="comment">// Otherwise it is not</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组的存储">数组的存储</h2><p>在JavaScript中数组元素存储是稀疏的，这也就意味着数组的下标不会落在一个连续的数字范围由，只有那些真正存储在数组中的元素才能够分配到内存，其余均不会浪费你宝贵的内存空间。比如如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//声明一个空数组 </span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">'jeff'</span>;</span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">'jade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">//1001 嗯。从0到1000</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">999</span>]);   <span class="comment">//undefined 没有定义</span></span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中数组元素本身，可以是各种类型Null，function，string，object对象等都可以。这一点毋庸置疑；但前两日在学习数组<code>reduce</code>方法的时候，竟然被涨了姿势了，代码走起：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">'pear'</span>,<span class="string">'jade'</span>];</span><br><span class="line"><span class="keyword">var</span> arrJade;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev---:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next---:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        prev[next] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); // [object Array]</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(prev));</span><br><span class="line">        arrJade = prev;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, []);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"reduce With [] as an additional parameter:"</span>,passValue());</span><br><span class="line"><span class="comment">//reduce With [] as an additional parameter: [ apple: 1, orange: 1, pear: 1, jade: 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrJade.length); <span class="comment">// 0</span></span><br><span class="line">arrJade.push(<span class="string">'jade'</span>);    </span><br><span class="line"><span class="built_in">console</span>.log(arrJade);        <span class="comment">// [ 'jade', apple: 1, orange: 1, pear: 1, jade: 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrJade.apple);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，可以得到一个类Object对象的数组：只是被包裹的是<code>[]</code>,而非<code>{}</code>；且此时该“数组”是有length属性的，只不过length是0而已。这个“数组”，以console.log(Object.prototype.toString.call(arrJade));来判别是数组无疑。但是倘若类同如此这样直接定义一个“数组”，却是断然不可以的，请看如下代码：。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [apple: <span class="number">1</span>, orange: <span class="number">1</span>]; <span class="comment">//这么搞，编译都过不了，语法错误❌</span></span><br><span class="line"><span class="comment">//Uncaught SyntaxError: Unexpected token : ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//but,可以像使用reduce方法一样，可以构造出这样的数组！</span></span><br><span class="line"><span class="keyword">var</span> arrTest = [];</span><br><span class="line">arrTest[<span class="string">"apple"</span>] = <span class="number">1</span>;</span><br><span class="line">arrTest[<span class="string">"orange"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">//[apple: 1, orange: 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.length) <span class="comment">// 0</span></span><br><span class="line">arrTest.push(<span class="string">'pear'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">// ["pear", apple: 1, orange: 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.length) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.apple); <span class="comment">//1   arrTest['apple']当然也可以访问。</span></span><br><span class="line"></span><br><span class="line">arrTest[<span class="string">"pear"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">//["pear", apple: 1, orange: 1, pear: 1]</span></span><br></pre></td></tr></table></figure></p>
<p>既然这是一个数组，但为何不能直接如此构造，这一点现在还没搞搞明白，呜呜～。而这样：arrTest[“apple”] = 1; 操纵一个数组，无形的将该项元素对象化了，又没用<code>{}</code>将其包裹，致使其“游离”于此数组一级对象一列，数组能够直接访问。但是，又不在length计数范围。length的数组下表是有对应关系的，当然这里也不能使用数组带下标来访问了。</p>
<p>JS数组，对于诸如Number,String之类的类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引（即C中所说的保存了数据的指针）。这些数据时储存在堆中的某块区间中，堆栈并不是独立的，栈中也可以在堆中存放。那么那些直接游离在数组中的Object元素项，存储地是在哪儿呢？额额，还是没搞搞明白，!?(･_･;?。</p>
<p>对于JS，尚有诸多未知，待学待探究，即便是这随便一个属性：length！！！</p>
<p><a href="http://segmentfault.com/a/1190000000415572" target="_blank" rel="external">javascript 类数组</a><br><a href="http://www.html-js.com/article/1619" target="_blank" rel="external">JavaScript 的怪癖 8：“类数组对象”</a><br><a href="http://www.xiaoxiaozi.com/2009/06/29/1020/" target="_blank" rel="external">JavaScript 创建数组的方法和基本操作</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几日有在<a href="http://www.jeffjade.com/2015/09/25/2015-09-25-js-array/#">Javascript数组操作</a>一文中稍提及了数组的length属性；深入一点探究，就发现JS这length确有许多难为所知的特性。这就边学边探究下这朵奇葩属性;这里边深入边记载。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精妙JS代码段搜集]]></title>
    <link href="http://jeffjade.github.io/2015/10/06/2015-10-06-perfect-js-code/"/>
    <id>http://jeffjade.github.io/2015/10/06/2015-10-06-perfect-js-code/</id>
    <published>2015-10-06T09:00:00.000Z</published>
    <updated>2015-10-06T12:30:20.000Z</updated>
    <content type="html"><![CDATA[<p>现在到处都是JavaScript，倘若花点时间去体察，每次都能知道点新的东西。一旦你入了门，你总能从这里或是那里领悟到很多知识。一旦发现些许有意思的东西，总习惯先收藏起来。待到时技(时间＋技术)成熟，再去感觉他们的源代码，看一看它们是怎么办到的，览一览大牛们的“奇技淫巧”。这里便是关于所遇精妙JS代码的收藏室，愿随时间的渐行渐远，这里收集的日渐丰盈，技术也能“层林尽染”。</p>
<a id="more"></a>
<h2 id="CSS布局调试代码片段"><strong>CSS布局调试代码片段</strong></h2><p>在浏览器控制台运行此段代码(当然也只能在控制台运用)，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。当然这样的工具使用Chrome一些插件也易办到，但直接撸起如此代码，能够领悟到很多知识。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">    a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.jeffjade.com/img/css/console-css-outline.png" alt=""></p>
<h3 id="代码分析："><strong>代码分析：</strong></h3><p>这段代码是 Github 上的 140 bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>
<p>首先是需要选择页面上的所有元素，这里使用了只能在console调试工具中使用的$$函数，你可以在console中输入$$(‘a’)自己试一下。它会返回当前页面的所有anchor（链接）元素。<code>$$</code>与<code>document.querySelectorAll</code>是等价的，有兴趣可查看<a href="http://ourjs.com/detail/54ab768a5695544119000007" target="_blank" rel="external">$$和$选择器的历史</a>。</p>
<p>其次遍历所有元素，这里用的是<code>[].forEach.call(...)</code>，使用 <code>forEach</code> 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 [] 空数组来代替Array.prototype,更显简洁;得到所有元素的节点列表（NodeList），但是它并没有实现Array的所有接口，因此使用 $$(‘*’).forEach 会返回错误，这里使用<code>call</code>方法来更改forEach内部this环境，当然也可以使用<code>apply</code>。</p>
<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。这行代码使用了CSS的outline属性。在CSS渲染的盒子模型（Box Model）中，<strong>outline并不会改变元素及其布局的位置</strong>。这里较有意思的是：定义不同的颜色的色值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里想构造的其实是一个16进制的颜色值，即000000～ffffff;也就是parseInt(‘0’,16)到parseInt(‘ffffff’,16)之间的一个值；而<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'ffffff'</span>,<span class="number">16</span>) == <span class="number">16777215</span> == (<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>) == (<span class="number">1</span>&lt;&lt;<span class="number">24</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>Math.random(),得到的是一个0～1之间的浮点数；(Math.random()*(1&lt;&lt;24)，即得到0～16777215之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行int转换。这里用到了<code>~~</code>,可参见<a href="http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational－symbol/" target="_blank" rel="external">理解JS按为非运算符(~/~~ )</a>。当然可以将~~视为parseInt的简写。并且使用按位或 “|”操作符也可以得到相同的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.234567890</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.000000001</span>;</span><br><span class="line">~~a == <span class="number">0</span>|a == <span class="built_in">parseInt</span>(a, <span class="number">10</span>) == <span class="number">1</span></span><br><span class="line">~~b == <span class="number">0</span>|b == <span class="built_in">parseInt</span>(b, <span class="number">10</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>toString(16)</code>使用数字类型的toString方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用toString(16)转换成16进制，将此值赋予到页面上所有元素节点的outline附加属性上，就有了如图效果，它就是这样工作的。精致巧妙而实用非常，顶一个。</p>
<p>参考文章<a href="http://ourjs.com/detail/54be0a98232227083e000012" target="_blank" rel="external">从一行CSS调试代码中学到的JavaScript知识</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在到处都是JavaScript，倘若花点时间去体察，每次都能知道点新的东西。一旦你入了门，你总能从这里或是那里领悟到很多知识。一旦发现些许有意思的东西，总习惯先收藏起来。待到时技(时间＋技术)成熟，再去感觉他们的源代码，看一看它们是怎么办到的，览一览大牛们的“奇技淫巧”。这里便是关于所遇精妙JS代码的收藏室，愿随时间的渐行渐远，这里收集的日渐丰盈，技术也能“层林尽染”。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://jeffjade.github.io/tags/jQuery/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[〔转〕jQuery编程的最佳实践]]></title>
    <link href="http://jeffjade.github.io/2015/10/04/2015-10-03-use-jquery-better/"/>
    <id>http://jeffjade.github.io/2015/10/04/2015-10-03-use-jquery-better/</id>
    <published>2015-10-04T04:00:00.000Z</published>
    <updated>2015-10-06T08:56:56.000Z</updated>
    <content type="html"><![CDATA[<p>前几日看到这篇关于jQuery的文章，至少如今还觉得很好，就忍将不住的转了来；以备之后深加探究。此文出自“刘哇勇的部落格”<a href="http://www.cnblogs.com/Wayou/p/jquery_best_practise.html" target="_blank" rel="external">jQuery编程的最佳实践</a>；原文出自<a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">Coding Standards &amp; Best Practices</a>。另有一篇关于jQuery的不错文章<a href="http://code.tutsplus.com/tutorials/14-helpful-jquery-tricks-notes-and-best-practices--net-14405" target="_blank" rel="external">14 Helpful jQuery Tricks, Notes, and Best Practices</a>，值得一览，译文在此<a href="http://www.iinterest.net/2010/09/27/%E8%BD%AC14%E6%9D%A1%E5%85%B3%E4%BA%8Ejquery%E7%9A%84%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">14条关于jQuery的知识</a>。</p>
<a id="more"></a>
<p>好像是feedly订阅里看到的文章，读完后觉得非常不错，译之备用，多看受益。</p>
<h2 id="加载jQuery"><strong>加载jQuery</strong></h2><ol>
<li><p>坚持使用CDN来加载jQuery，这种别人服务器免费帮你托管文件的便宜干嘛不占呢。<a href="http://www.sitepoint.com/7-reasons-to-use-a-cdn/" target="_blank" rel="external">点击查看</a>使用CDN的好处，<a href="http://lab.abhinayrathore.com/jquery-standards/#jQueryCND" target="_blank" rel="external">点此</a>查看一些主流的jQuery CDN地址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.jQuery || <span class="built_in">document</span>.write(<span class="string">'&lt;script src="js/jquery-1.11.0.min.js" type="text/javascript"&gt;&lt;\/script&gt;'</span>)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安全起见，最好还是提供一个本地备份以便在无法从远程CDN服务器获取jQuery时网站也能工作，如上面代码所示。<a href="https://css-tricks.com/snippets/jquery/fallback-for-cdn-hosted-jquery/" target="_blank" rel="external">详情见此</a>。</p>
</li>
<li><p>使用<a href="http://www.paulirish.com/2010/the-protocol-relative-url/" target="_blank" rel="external">裸协议</a>的URL（也就是说去掉http:或者https:），如上面代码展示的那样。</p>
</li>
<li><p>如果可能，尽量将你的JavaScript和jQuery代码放到页面底部。详情移步<a href="https://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-6-move-scripts-bottom-7200.html" target="_blank" rel="external">这里</a>，或者查看一个<a href="https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html" target="_blank" rel="external">HTML5页面标准模板</a>。</p>
</li>
<li><p>该使用哪个版本？</p>
</li>
</ol>
<ul>
<li>如果你想兼容IE678请表用2.x的版本</li>
<li>针对极少数不用考虑兼容性的幸运儿，极力推荐使用最新版本的jQuery</li>
<li>当从CDN服务器加载jQuery时，最好把版本写全（比如1.11.0而不是1.11或者直接写个1）</li>
<li>千万莫重复加载.</li>
</ul>
<ol>
<li><p>如果你同时还使用了其他JS框架诸如Prototype, MooTools, Zepto云云，因为他们也使用了$符号，所以你就表再用美刀符号来进行jQuery 编码了，而请用<code>jQuery</code>代替。并且调用<code>$.noConflict()</code>保证不会有冲突出现。</p>
</li>
<li><p>要检测浏览器对一些新特性是否支持，请用<a href="https://modernizr.com" target="_blank" rel="external">Modernizr</a>。插播广告：<a href="http://www.cnblogs.com/Wayou/p/why_jquery_obselete_brower_detecting.html" target="_blank" rel="external">论为毛不检测浏览器</a>。</p>
</li>
</ol>
<h2 id="关于变量"><strong>关于变量</strong></h2><ol>
<li><p>jQuery类型的变量最好加个$前缀。</p>
</li>
<li><p>时常将jQuery选择器返回的内容存进变量以便重用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $products = $(<span class="string">"div.products"</span>); <span class="comment">// 慢</span></span><br><span class="line"><span class="keyword">var</span> $products = $(<span class="string">".products"</span>); <span class="comment">// 快</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用驼峰命名.</p>
</li>
</ol>
<h2 id="关于选择器"><strong>关于选择器</strong></h2><ol>
<li><p>尽量ID选择器。其背后机理其实是调用原生的<code>document.getElementById()</code>，所以速度较其他选择器快。</p>
</li>
<li><p>使用类选择器时表指定元素的类型。不信你看这个<a href="http://jsperf.com/jqeury-selector-test" target="_blank" rel="external">性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $products = $(<span class="string">"div.products"</span>); <span class="comment">// 慢</span></span><br><span class="line"><span class="keyword">var</span> $products = $(<span class="string">".products"</span>); <span class="comment">// 快</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ID父亲容器下面再查找子元素请用.find()方法。这样做快的原因是通过id选择元素不会使用Sizzle引擎。详情看这里 </p>
</li>
<li><p>多级查找中，右边尽量指定得详细点而左边则尽量简单点。了解更多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 丑陋</span></span><br><span class="line">$(<span class="string">"div.data .gonzalez"</span>);</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line">$(<span class="string">".data td.gonzalez"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免冗余。<a href="http://learn.jquery.com/performance/optimize-selectors/" target="_blank" rel="external">详情</a>或者查看<a href="http://jsperf.com/avoid-excessive-specificity" target="_blank" rel="external">性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".data table.attendees td.gonzalez"</span>);</span><br><span class="line"><span class="comment">// 好的方式：去掉了中间的冗余</span></span><br><span class="line">$(<span class="string">".data td.gonzalez"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定选择的上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 劣质的代码：因为需要遍历整个DOM来找到.class</span></span><br><span class="line">$(<span class="string">'.class'</span>);</span><br><span class="line"><span class="comment">// 高品代码：因为只需在指定容器范围内进行查找</span></span><br><span class="line">$(<span class="string">'.class'</span>, <span class="string">'#class-container'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表使用万能选择器。查看<a href="http://learn.jquery.com/performance/optimize-selectors/" target="_blank" rel="external">具体阐释</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.container &gt; *'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'div.container'</span>).children(); <span class="comment">// 棒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>警惕隐式的万能选择器。省略的情况下其实使用的就是*号通配符。更多信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.someclass :radio'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'div.someclass input:radio'</span>); <span class="comment">// 棒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ID已经表示唯一了，背后使用的是document.getElementById()，所以表跟其他选择器混搭了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#outer #inner'</span>); <span class="comment">// 脏</span></span><br><span class="line">$(<span class="string">'div#inner'</span>); <span class="comment">// 乱</span></span><br><span class="line">$(<span class="string">'.outer-container #inner'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'#inner'</span>); <span class="comment">// 干净利落，后台只需调用document.getElementById()</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="DOM操作相关"><strong>DOM操作相关</strong></h2><ol>
<li>操作任何元素前先将其从文档卸载，完了再贴回去。<a href="http://learn.jquery.com/performance/detach-elements-before-work-with-them/" target="_blank" rel="external">这事儿还能说细点</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list-container &gt; ul"</span>).detach();</span><br><span class="line"><span class="comment">//...一大堆对$myList的处理</span></span><br><span class="line">$myList.appendTo(<span class="string">"#list-container"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.代码里将HTML组织好后再一次性贴到DOM中去。<a href="http://learn.jquery.com/performance/append-outside-loop/" target="_blank" rel="external">具体来说</a>，<a href="http://jsperf.com/jquery-append-vs-string-concat" target="_blank" rel="external">性能比较</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样不好</span></span><br><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    $myList.append(<span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这样好</span></span><br><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list"</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    list += <span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$myList.html(list);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 但这样更好</span></span><br><span class="line"><span class="keyword">var</span> array = []; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    array[i] = <span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>; </span><br><span class="line">&#125;</span><br><span class="line">$myList.html(array.join(<span class="string">''</span>));</span><br></pre></td></tr></table></figure></p>
<p>3.不要处理不存在的元素。<a href="http://learn.jquery.com/performance/dont-act-on-absent-elements/" target="_blank" rel="external">详情</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无良的做法：jQuery后台要跑完三个函数后才会知道这个元素其实根本不存在</span></span><br><span class="line">$(<span class="string">"#nosuchthing"</span>).slideUp();</span><br><span class="line"><span class="comment">// 应该这样</span></span><br><span class="line"><span class="keyword">var</span> $mySelection = $(<span class="string">"#nosuchthing"</span>);</span><br><span class="line"><span class="keyword">if</span> ($mySelection.length) &#123;</span><br><span class="line">    $mySelection.slideUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件相关"><strong>事件相关</strong></h2><ol>
<li><p>一个页面只写一个文档ready事件的处理程序。这样代码既清晰好调试，又容易跟踪代码的进程。</p>
</li>
<li><p>表用匿名函数来做事件的回调。匿名函数不易调试维护测试和复用。或许你想较真，看看<a href="http://learn.jquery.com/code-organization/beware-anonymous-functions/" target="_blank" rel="external">这里</a>吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;...&#125;); <span class="comment">// 表这样</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLinkClickHandler</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, myLinkClickHandler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理文档ready事件的回调也表用匿名函数，匿名函数不易调试维护测试和复用:(</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; ... &#125;); <span class="comment">// 糟糕的做法：无法利用此函数也无法为其写测试用例</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line">$(initPage); <span class="comment">// 抑或 $(document).ready(initPage);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里你可以进行程序的初始化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进一步，最好也将ready事件的处理程序放到外部文件中引入到页面，而页面中内嵌的代码只需调用即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"my-document-ready.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="comment">// 初始化一些必要的全局变量</span></span><br><span class="line">    $(<span class="built_in">document</span>).ready(initPage); <span class="comment">// 抑或 $(initPage);</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>千万表写内联到HTML的JS代码，这是调试的梦魇！应该总是用jQuery来绑定事件自带程序，这样也方便随时动态地取消绑定。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id="myLink" href="#" onclick="myEventHandler();"&gt;my link&lt;/a&gt; &lt;!--不好 --&gt;</span><br><span class="line">$("#myLink").on("click", myEventHandler); // GOOD</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可能尽量在绑定事件处理程序时使用一个命名空间，这样可以方便地取消绑定而不会影响其他绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click.mySpecialClick"</span>, myEventHandler); <span class="comment">// 不错</span></span><br><span class="line"><span class="comment">// 之后，让我们优雅地解除绑定</span></span><br><span class="line">$(<span class="string">"#myLink"</span>).unbind(<span class="string">"click.mySpecialClick"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="异步操作"><strong>异步操作</strong></h2><ol>
<li><p>直接用$.ajax()而表去用.getJson() 或 .get(),因为jQuery内部还是将其转为前者</p>
</li>
<li><p>表对HTTPS站点使用HTTP去发起请求，最好干脆就表指定（将HTTP或者HTTPS从你的URL中移除）</p>
</li>
<li><p>表在链接里面嵌参数，请使用专门的参数设置来传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不易阅读的代码...</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"something.php?param1=test1&amp;param2=test2"</span>,</span><br><span class="line">    ....</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更易阅读...</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"something.php"</span>,</span><br><span class="line">    data: &#123; param1: test1, param2: test2 &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量指明数据类型以便你自己清楚要处理什么样的数据（见下方会提到的Ajax模板）</p>
</li>
<li><p>对于异步动态加载的内容，最好使用代理来绑定事件处理程序。这样的好处是对于之后动态加载的元素事件同样有效。你或许想<a href="http://api.jquery.com/on/" target="_blank" rel="external">了解更多</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#parent-container"</span>).on(<span class="string">"click"</span>, <span class="string">"a"</span>, delegatedClickHandlerForAjax);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>6.使用Promise模式。<a href="http://www.htmlgoodies.com/beyond/javascript/making-promises-with-jquery-deferred.html" target="_blank" rel="external">更多例子</a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123; <span class="keyword">...</span> &#125;).then(successHandler, failureHandler);</span><br><span class="line"> </span><br><span class="line">// 抑或</span><br><span class="line">var jqxhr = $.ajax(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">jqxhr.done(successHandler);</span><br><span class="line">jqxhr.fail(failureHandler);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>标准的Ajax模板一分。<a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">追寻根源</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    type: <span class="string">"GET"</span>, <span class="comment">// 默认为GET,你可以根据需要更改</span></span><br><span class="line">    cache: <span class="literal">true</span>, <span class="comment">// 默认为true,但对于script,jsonp类型为false,可以自行设置</span></span><br><span class="line">    data: &#123;&#125;, <span class="comment">// 将请求参数放这里.</span></span><br><span class="line">    dataType: <span class="string">"json"</span>, <span class="comment">// 指定想要的数据类型</span></span><br><span class="line">    jsonp: <span class="string">"callback"</span>, <span class="comment">// 指定回调处理JSONP类型的请求</span></span><br><span class="line">    statusCode: &#123; <span class="comment">// 如果你想处理各状态的错误的话</span></span><br><span class="line">        <span class="number">404</span>: handler404,</span><br><span class="line">        <span class="number">500</span>: handler500</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">jqxhr.done(successHandler);</span><br><span class="line">jqxhr.fail(failureHandler);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="动画与特效"><strong>动画与特效</strong></h2><ol>
<li>保持一个始终如一风格统一的动画实现</li>
<li>紧遵用户体验，表滥用动画特效</li>
</ol>
<p>使用简洁的显示隐藏，状态切换，滑入滑出等效果来展示元素<br>使用预设值来设置动画的速度’fast’，’slow’，或者400（中等速度）</p>
<h2 id="插件相关"><strong>插件相关</strong></h2><ol>
<li>始终选择一个有良好支持，完善文档，全面测试过并且社区活跃的插件</li>
<li>注意所用插件与当前使用的jQuery版本是否兼容</li>
<li>一些常用功能应该写成jQuery插件。<a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">一分jQuery插件的编写模板</a></li>
</ol>
<h2 id="链式句法"><strong>链式句法</strong></h2><ol>
<li><p>除了用变量将jQuery选择器返回的结果保存，还可以利用好链式调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myDiv"</span>).addClass(<span class="string">"error"</span>).show();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当链式调用多达3次以上或代码因绑定回调略显复杂时，使用换行和适当的缩进来提高代码的可读性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>)</span><br><span class="line">    .addClass(<span class="string">"bold"</span>)</span><br><span class="line">    .on(<span class="string">"click"</span>, myClickHandler)</span><br><span class="line">    .on(<span class="string">"mouseover"</span>, myMouseOverHandler)</span><br><span class="line">    .show();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于特别长的调用最好还是用变量保存下中间结果来简化代码。</p>
</li>
</ol>
<h2 id="其他"><strong>其他</strong></h2><ol>
<li><p>使用对象字面量来传递参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$myLink.attr(<span class="string">"href"</span>, <span class="string">"#"</span>).attr(<span class="string">"title"</span>, <span class="string">"my link"</span>).attr(<span class="string">"rel"</span>, <span class="string">"external"</span>); <span class="comment">// 糟糕：调用了三次attr</span></span><br><span class="line"><span class="comment">// 不错，只调用了一次attr</span></span><br><span class="line">$myLink.attr(&#123;</span><br><span class="line">    href: <span class="string">"#"</span>,</span><br><span class="line">    title: <span class="string">"my link"</span>,</span><br><span class="line">    rel: <span class="string">"external"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表将CSS与jQuery杂揉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#mydiv"</span>).css(&#123;<span class="string">'color'</span>:red, <span class="string">'font-weight'</span>:<span class="string">'bold'</span>&#125;); <span class="comment">// 不好</span></span><br><span class="line"></span><br><span class="line">.error &#123;<span class="comment">/* 不错 */</span></span><br><span class="line">    color: red;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#mydiv"</span>).addClass(<span class="string">"error"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>时刻关注官方Changelog，表使用摒弃了的方法。<a href="http://api.jquery.com/category/deprecated/" target="_blank" rel="external">点此</a>查看所有废弃的方法.</p>
</li>
<li><p>适时地使用原生JavaScript。<a href="http://jsperf.com/document-getelementbyid-vs-jquery/3" target="_blank" rel="external">一些与此有关的性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myId"</span>); <span class="comment">// 多少还是会逊色于...</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myId"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="REFERENCE"><strong>REFERENCE</strong></h2><p>原文：Coding Standards &amp; Best Practices <a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">http://lab.abhinayrathore.com/jquery-standards/</a></p>
<p>原文的reference<br>jQuery Performance: <a href="http://learn.jquery.com/performance/" target="_blank" rel="external">http://learn.jquery.com/performance/</a><br>jQuery Learn: <a href="http://learn.jquery.com" target="_blank" rel="external">http://learn.jquery.com</a><br>jQuery API Docs: <a href="http://api.jquery.com/" target="_blank" rel="external">http://api.jquery.com/</a><br>jQuery Coding Standards and Best Practice: <a href="http://www.jameswiseman.com/blog/2010/04/20/jquery-standards-and-best-practice/" target="_blank" rel="external">http://www.jameswiseman.com/blog/2010/04/20/jquery-standards-and-best-practice/</a><br>jQuery Plugin Boilerplate: <a href="http://stefangabos.ro/jquery/jquery-plugin-boilerplate-revisited/" target="_blank" rel="external">http://stefangabos.ro/jquery/jquery-plugin-boilerplate-revisited/</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几日看到这篇关于jQuery的文章，至少如今还觉得很好，就忍将不住的转了来；以备之后深加探究。此文出自“刘哇勇的部落格”<a href="http://www.cnblogs.com/Wayou/p/jquery_best_practise.html">jQuery编程的最佳实践</a>；原文出自<a href="http://lab.abhinayrathore.com/jquery-standards/">Coding Standards &amp; Best Practices</a>。另有一篇关于jQuery的不错文章<a href="http://code.tutsplus.com/tutorials/14-helpful-jquery-tricks-notes-and-best-practices--net-14405">14 Helpful jQuery Tricks, Notes, and Best Practices</a>，值得一览，译文在此<a href="http://www.iinterest.net/2010/09/27/%E8%BD%AC14%E6%9D%A1%E5%85%B3%E4%BA%8Ejquery%E7%9A%84%E7%9F%A5%E8%AF%86/">14条关于jQuery的知识</a>。</p>]]>
    
    </summary>
    
      <category term="jQuery" scheme="http://jeffjade.github.io/tags/jQuery/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript数组操作]]></title>
    <link href="http://jeffjade.github.io/2015/09/25/2015-09-25-js-array/"/>
    <id>http://jeffjade.github.io/2015/09/25/2015-09-25-js-array/</id>
    <published>2015-09-25T13:30:00.000Z</published>
    <updated>2015-10-08T13:34:49.000Z</updated>
    <content type="html"><![CDATA[<p>使用JS也算有段时日，然对于数组的使用，总局限于很初级水平，且每每使用总要查下API，或者写个小Demo测试下才算放心，一来二去，浪费不少时间；思虑下，堪能如此继续之？当狠心深学下方是正道。</p>
<a id="more"></a>
<h2 id="一,_数组常用方法">一, <strong>数组常用方法</strong></h2><h3 id="1-_数组的创建">1. <strong>数组的创建</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>();　<span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([size]);　<span class="comment">//创建一个数组并指定长度，注意不是上限，是长度</span></span><br><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([element0[, element1[, ...[, elementN]]]]);　<span class="comment">//创建一个数组并赋值</span></span><br></pre></td></tr></table></figure>
<p>要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变</p>
<h3 id="2-_数组的元素的访问">2. <strong>数组的元素的访问</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testGetArrValue=arrayObj[<span class="number">1</span>]; <span class="comment">//获取数组的元素值</span></span><br><span class="line">arrayObj[<span class="number">1</span>]= <span class="string">"这是新值"</span>; <span class="comment">//给数组元素赋予新的值</span></span><br></pre></td></tr></table></figure>
<h3 id="3-_数组元素的添加">3. <strong>数组元素的添加</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj. push([item1 [item2 [. . . [itemN ]]]]);<span class="comment">// 将一个或多个新元素添加到数组结尾，并返回数组新长度</span></span><br><span class="line">arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);<span class="comment">// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度</span></span><br><span class="line">arrayObj.splice(insertPos,<span class="number">0</span>,[item1[, item2[, . . . [,itemN]]]]);<span class="comment">//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回""。</span></span><br></pre></td></tr></table></figure>
<h3 id="4-_数组元素的删除">4. <strong>数组元素的删除</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.pop(); <span class="comment">//移除最后一个元素并返回该元素值</span></span><br><span class="line">arrayObj.shift(); <span class="comment">//移除最前一个元素并返回该元素值，数组中元素自动前移</span></span><br><span class="line">arrayObj.splice(deletePos,deleteCount); <span class="comment">//删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="5-_数组的截取和合并">5. <strong>数组的截取和合并</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.slice(start, [end]); <span class="comment">//以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素</span></span><br><span class="line">arrayObj.concat([item1[, item2[, . . . [,itemN]]]]); <span class="comment">//将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="6-_数组的拷贝">6. <strong>数组的拷贝</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.slice(<span class="number">0</span>); <span class="comment">//返回数组的拷贝数组，注意是一个新的数组，不是指向</span></span><br><span class="line">arrayObj.concat(); <span class="comment">//返回数组的拷贝数组，注意是一个新的数组，不是指向</span></span><br></pre></td></tr></table></figure>
<h3 id="7-_数组元素的排序">7. <strong>数组元素的排序</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.reverse(); <span class="comment">//反转元素（最前的排到最后、最后的排到最前），返回数组地址</span></span><br><span class="line">arrayObj.sort(); <span class="comment">//对数组元素排序，返回数组地址</span></span><br></pre></td></tr></table></figure>
<h3 id="8-_数组元素的字符串化">8. <strong>数组元素的字符串化</strong></h3><p><code>join()</code>方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.join(separator); <span class="comment">//返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure></p>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<p><code>valueOf</code>: 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></span><br></pre></td></tr></table></figure></p>
<p>toLocaleString 、toString：可以看作是join的特殊用法，不常用;<br><strong>toLocaleString()</strong>: 方法可根据本地时间把 Date 对象转换为字符串，并返回结果。</p>
<p><strong>toString</strong>:把数组转换为字符串，并返回结果。</p>
<p><strong>lastIndexOf</strong>：返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。</p>
<p><strong>toSource()</strong>: 返回一个字符串,代表该数组的源代码.<font color="red">该特性是非标准的，请尽量不要在生产环境中使用它！</font> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toSource" target="_blank" rel="external">Array.prototype.toSource()</a></p>
<h2 id="二、数组对象的3个属性"><strong>二、数组对象的3个属性</strong></h2><h3 id="1-_length属性">1. <strong>length属性</strong></h3><p>Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];<span class="comment">//定义了一个包含10个数字的数组</span></span><br><span class="line">alert(arr.length); <span class="comment">//显示数组的长度10</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">12</span>; <span class="comment">//增大数组的长度</span></span><br><span class="line">alert(arr.length); <span class="comment">//显示数组的长度已经变为12</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素的值，为56</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">5</span>; <span class="comment">//将数组的长度减少到5，索引等于或超过5的元素被丢弃</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素已经变为"undefined"</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">10</span>; <span class="comment">//将数组长度恢复为10</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//虽然长度被恢复为10，但第9个元素却无法收回，显示"undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码我们可以清楚的看到length属性的性质。但length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure></p>
<p>代码中同样是先定义了一个包含10个数字的数组，通过alert语句可以看出其长度为10。随后使用了索引为15的元素，将其赋值为15，即 arr[15]=34，这时再用alert语句输出数组的长度，得到的是16。无论如何，对于习惯于强类型编程的开发人员来说，这是一个很令人惊讶的特性。事实上，使用new Array()形式创建的数组，其初始长度就是为0，正是对其中未定义元素的操作，才使数组的长度发生变化。</p>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，<strong>不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>
<p>由上面的介绍可以看到，length属性是如此的神奇，利用它可以方便的增加或者减少数组的容量。因此对length属性的深入了解，有助于在开发过程中灵活运用。</p>
<h3 id="2-_prototype_属性">2. <strong>prototype 属性</strong></h3><p>返回对象类型原型的引用。prototype 属性是 object 共有的。</p>
<p><strong>objectName.prototype</strong>:objectName 参数是object对象的名称。<br>说明：用 prototype 属性提供对象的类的一组基本功能。 对象的新实例“继承”赋予该对象原型的操作。<br>对于数组对象，以以下例子说明prototype 属性的用途。</p>
<p>给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_max</span><span class="params">()</span></span><br><span class="line"> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">    max = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; <span class="keyword">this</span>[i])</span><br><span class="line">        max = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.max = array_max;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> y = x.max();</span><br></pre></td></tr></table></figure></p>
<p>该代码执行后，y 保存数组 x 中的最大值，即：6。</p>
<h3 id="3-_constructor_属性">3. <strong>constructor 属性</strong></h3><p>表示创建对象的函数。object.constructor //object是对象或函数的名称。</p>
<p>说明：constructor 属性是所有具有 prototype 的对象的成员。它们包括除 Global 和 Math 对象以外的所有 JScript 固有对象。constructor 属性保存了对构造特定对象实例的函数的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hi"</span>);</span><br><span class="line"><span class="keyword">if</span> (x.constructor == <span class="built_in">String</span>) <span class="comment">// 进行处理（条件为真）。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 函数体。</span></span><br><span class="line">&#125;</span><br><span class="line">y = <span class="keyword">new</span> MyFunc;</span><br><span class="line"><span class="keyword">if</span> (y.constructor == MyFunc) <span class="comment">// 进行处理（条件为真）。</span></span><br><span class="line"></span><br><span class="line">y = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="三、判断是否为数组"><strong>三、判断是否为数组</strong></h2><p>js因为设计上的某些缺陷，导致在对于Array的判断，也是颇费周折的。<br><code>typeof 操作符</code>:对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任，但是为Array时,难免会让人失望：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);</span><br><span class="line">alert(<span class="keyword">typeof</span>(arr));  <span class="comment">// Object</span></span><br></pre></td></tr></table></figure></p>
<p><code>instanceof 操作符</code>: 运算符会返回一个 Boolean 值，指出对象是否是特定类的一个实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayStr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);</span><br><span class="line">alert(arrayStr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>虽然此时能够完好的工作，但，事实上在多个frame中穿梭就会产生大问题了。所以~~~<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);    </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);    </span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length-<span class="number">1</span>].Array;       </span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);<span class="comment">//这个写法IE大哥下是不支持的，FF下才有</span></span><br><span class="line">       </span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false </span></span><br><span class="line">alert(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ECMA-262中规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。于是利用这点，就有了下面这种方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：）。这也是Array.isArray()方法的兼容旧环境（Polyfill）。</p>
<p>如此很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定！当然也可以写成如下这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray2</span> <span class="params">(v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.apply(v) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要注意的是：toString方法极有可能被重写，所以需要使用的时候，可以直接使用Object.prototype.toString()方法。</p>
<p><code>Array.isArray()</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="external">^See</a>方法用来判断某个值是否为数组。如果是，则返回 true，否则返回 false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; __proto__: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="四,_数组迭代过程"><strong>四, 数组迭代过程</strong></h2><h3 id="filter()_^See"><strong>filter()</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">^See</a></h3><p><strong>方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</strong><br>语法：arr.filter(callback[, thisArg])<br>如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。</p>
<blockquote>
<p>filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。</p>
</blockquote>
<p><strong>示例</strong>：筛选排除掉所有的小值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</span><br><span class="line"><span class="comment">// filtered is [12, 130, 44]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="forEach()_^See">forEach() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">^See</a></h3><p><strong>方法让数组的每一项都执行一次给定的函数。</strong><br>语法: array.forEach(callback[, thisArg])</p>
<blockquote>
<p>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。</p>
</blockquote>
<p><em>forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</em> <strong>注意： 没有办法中止 forEach 循环。如果要中止，可使用  Array.every 或 Array.some。见下面的例子。</strong></p>
<p><strong>示例1</strong>:打印出数组的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArrayElements</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a["</span> + index + <span class="string">"] = "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(logArrayElements);</span><br><span class="line"><span class="comment">// logs:</span></span><br><span class="line"><span class="comment">// a[0] = 2</span></span><br><span class="line"><span class="comment">// a[1] = 5</span></span><br><span class="line"><span class="comment">// a[2] = 9</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2</strong>:一个可以克隆对象的函数<br>使用下面的代码可以复制一个给定的对象,虽然有很多不同的复制对象的方法.不过下面介绍的这种方法使用了Array.prototype.forEach和其他一些ECMAScript 5中的Object.*函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create( <span class="built_in">Object</span>.getPrototypeOf(o) );</span><br><span class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line"></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(copy, name, desc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = copy(o1); <span class="comment">// o2 looks like o1 now</span></span><br></pre></td></tr></table></figure></p>
<h3 id="every()_^See">every() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">^See</a></h3><p><strong>方法测试数组的所有元素是否都通过了指定函数的测试。</strong><br>语法:arr.every(callback[, thisArg])</p>
<blockquote>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 falsy（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。<strong>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</strong> <em>every 不会改变原数组。</em></p>
</blockquote>
<p>实例：检测所有数组元素的大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测数组中的所有元素是否都大于 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="map()_^See">map() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">^See</a></h3><p><strong>方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</strong></p>
<p>语法: array.map(callback[, thisArg])</p>
<blockquote>
<p>map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。<strong>map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。</strong></p>
</blockquote>
<p>实例一：求数组中每个元素的平方根<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个 String  上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map</span><br><span class="line"><span class="keyword">var</span> a = map.call(<span class="string">"Hello World"</span>, <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123; <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>); &#125;)</span><br><span class="line"><span class="comment">// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]</span></span><br></pre></td></tr></table></figure></p>
<p>通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。比如下面的语句返回什么呢:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// 你可能觉的会是[1, 2, 3]</span></span><br><span class="line"><span class="comment">// 但实际的结果是 [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure></p>
<p>通常使用parseInt时,只需要传递一个参数.但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句”alert(parseInt.length)===2”来验证. </p>
<p>map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.<br>第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN。 因此此时应该使用如下的用户函数returnInt：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span><span class="params">(element)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(returnInt);</span><br><span class="line"><span class="comment">// 返回[1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="some()_^See">some() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external">^See</a></h3><p><strong>方法测试数组中的某些元素是否通过了指定函数的测试。</strong></p>
<p>语法: arr.some(callback[, thisArg])</p>
<blockquote>
<p><strong>描述</strong>:some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
</blockquote>
<p>示例：测试数组元素的值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测在数组中是否有元素大于 10。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reduce()_^See">reduce() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">^See</a></h3><p><strong>接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</strong><br>语法: arr.reduce(callback,[initialValue])<br><strong>callback:</strong>执行数组中每个值的函数，包含四个参数</p>
<ul>
<li>previousValue:上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue 数组中当前被处理的元素</li>
<li>index 当前元素在数组中的索引</li>
<li>array 调用 reduce 的数组<br><strong>initialValue:</strong> 作为第一次调用 callback 的第一个参数。</li>
</ul>
<blockquote>
<p><strong>描述</strong>:reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>
<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>
<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
</blockquote>
<p>示例1：将数组所有项相加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// total == 6</span></span><br></pre></td></tr></table></figure></p>
<p>示例2: 数组扁平化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>示例2: 统计一个数组中有多少个不重复的单词</p>
<p>不使用reduce时的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWordCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>, l = arr.length; i&lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = arr[i];</span><br><span class="line">        obj[item] = (obj[item] +<span class="number">1</span> ) || <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getWordCnt());</span><br></pre></td></tr></table></figure></p>
<p>使用reduce()后的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWordCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        prev[next] = (prev[next] + <span class="number">1</span>) || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getWordCnt());</span><br></pre></td></tr></table></figure>
<p>这其中一个需要注意的点在于，initialValue提供与否对prev和next的影响；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二者的区别，在console中运行一下即可知晓*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">'pear'</span>,<span class="string">'jade'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noPassValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); //prev type:string</span></span><br><span class="line">        <span class="keyword">return</span> prev + <span class="string">" "</span> +next;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        prev[next] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); // object</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"No Additional parameter:"</span>,noPassValue());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"With &#123;&#125; as an additional parameter:"</span>,passValue());</span><br></pre></td></tr></table></figure></p>
<h2 id="一点总结："><strong>一点总结：</strong></h2><p>pop,push,reverse,shift,sort,splice,unshift  会改变原数组<br>join,concat,indexOf,lastIndexOf,slice,toString 不会改变原数组<br>map,filter,some,every,reduce,forEach这些迭代方法不会改变原数组</p>
<p>几个注意点：</p>
<ol>
<li>shift,pop会返回那个被删除的元素</li>
<li>splice 会返回被删除元素组成的数组，或者为空数组</li>
<li>push 会返回新数组长度</li>
<li>some 在有true的时候停止</li>
<li>every 在有false的时候停止</li>
<li>上述的迭代方法可以在最后追加一个参数thisArg,它是执行 callback 时的 this 值。</li>
</ol>
<p>JavaScript的数据类型分为：值类型和引用类型(地址值)；而常见的引用类型有Object和Array／数组的存储模型中，如果是诸如Number,String之类的类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引（即C中所说的保存了数据的指针）。这些数据时储存在堆中的某块区间中，堆栈并不是独立的，栈中也可以在堆中存放。在使用Array的进行赋值操作的时候，也当注意是否要进行深度拷贝复制(可借助arr.slice(0))，以免造成对自身污染。对于Js数据，其实内容还是还有很多需要学习的，比如ArrayBuffer等。根据学以致用的原则，这些等到需要的时候再去学吧。</p>
<p>参考文章如下：<br><a href="http://www.cnblogs.com/qiantuwuliang/archive/2011/01/08/1930499.html" target="_blank" rel="external">js数组操作</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1250" target="_blank" rel="external">js如何判断一个对象是不是Array？</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_.E6.96.B9.E6.B3.95" target="_blank" rel="external">MDN-Array</a><br><a href="http://segmentfault.com/a/1190000002753931?utm_source=tuicool" target="_blank" rel="external">盘点JavaScript里好用的原生API</a><br><a href="http://ourjs.com/detail/54a9f2ba5695544119000005" target="_blank" rel="external">5个现在就该使用的数组Array方法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用JS也算有段时日，然对于数组的使用，总局限于很初级水平，且每每使用总要查下API，或者写个小Demo测试下才算放心，一来二去，浪费不少时间；思虑下，堪能如此继续之？当狠心深学下方是正道。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅地使用Sublime Text]]></title>
    <link href="http://jeffjade.github.io/2015/09/17/2015-04-17-toss-sublime-text/"/>
    <id>http://jeffjade.github.io/2015/09/17/2015-04-17-toss-sublime-text/</id>
    <published>2015-09-17T04:50:00.000Z</published>
    <updated>2015-09-17T05:30:41.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。</p>
<a id="more"></a>
<h2 id="Sublime_Text_2和3的对比"><strong>Sublime Text 2和3的对比</strong></h2><p>相比于2，Sublime Text 3就秒启动一项，就压倒性地胜利了。因此在之后的叙述中都以Sublime Text 3为主角。并且3一直在不断的完善更新，具体的差异可参看<a href="http://www.sublimetext.com/blog/" target="_blank" rel="external">Sublime Blog</a>.简单的说：</p>
<blockquote>
<ul>
<li>ST3支持在项目目录里面寻找变量</li>
<li>提供了对标签页更好地支持（更多的命令和快捷键）</li>
<li>加快了程序运行的速度</li>
<li>更新了API，使用Python3.3</li>
</ul>
</blockquote>
<p>强烈推荐朋友们使用3! 唯快不破，不解释。</p>
<h2 id="Sublime_Text_3安装插件"><strong>Sublime Text 3安装插件</strong></h2><p>Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。</p>
<ul>
<li><p><strong>插件安装方式一：直接安装：</strong></p>
<blockquote>
<p>安装Sublime text 3插件很方便，可以直接下载安装包解压缩到Packages目录（菜单-&gt;preferences-&gt;packages）。</p>
</blockquote>
</li>
<li><p><strong>插件安装方式二：使用Package Control组件安装：</strong></p>
<blockquote>
<p>按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）粘贴以下代码到底部命令行并回车：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>重启Sublime Text 3。如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
</blockquote>
<h2 id="Sublime_Text_3推荐插件"><strong>Sublime Text 3推荐插件</strong></h2><p>根据自己的需要定制属于自己的强大插件集；下面是一些常用的推荐。<br><a href="http://www.jianshu.com/p/5905f927d01b" target="_blank" rel="external">Sublime Text3插件：增强篇</a><br><a href="http://www.open-open.com/news/view/26d731" target="_blank" rel="external">20个强大的SublimeText插件</a><br>作为在移动端畅游的自己，推荐这么几款插件：</p>
<ul>
<li><strong><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">MarkDown Editing</a></strong><br>  SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。关于如何在SublimeText下高效些东西可参见文章：<a href="http://www.cnblogs.com/jadeboy/p/4165449.html" target="_blank" rel="external">sublime text 2(3)下的Markdown写作</a> 抑或是前段时间写下的<a href="http://www.jeffjade.com/2015/08/28/2015-08-28-Write-Morkdown/" target="_blank" rel="external">追寻高效工作的一路折腾㈡</a></li>
<li><strong><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">SideBarFolders</a></strong><br>  打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。<br>  <img src="http://www.jeffjade.com/img/toss/sublimetext-folder.png" alt="SideBarFolders"></li>
<li><strong><a href="http://wbond.net/sublime_packages/terminal" target="_blank" rel="external">Sublime Terminal</a></strong><br>  这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。</li>
<li><strong><a href="http://weslly.github.io/ColorPicker/" target="_blank" rel="external">ColorPicker</a></strong><br>  通常，如果你想使用一个颜色选择器则可能打开 Photoshop 或 GIMP。而在 Sublime Text 中，你可以使用内置的颜色选择器。安装完成后，只要按下Ctrl / Cmd + Shift + C 快捷键。</li>
<li><strong><a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">SublimeREPL</a></strong><br>  这可能是对程序员很有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）。</li>
<li><strong>终极王道</strong>：自己编写专用的Sublime Text插件。虽然说各个方面比如移动端，Web前段，服务器端，非Coder的Writer所需要的方便已经被集成在了不同的插件中。但譬如，需要快捷打开PC端的某个模拟器，便捷的进行某些校验，只要你想的到的基本都可以将其在插件内，以快捷键处理之。至于如何编写SublimeText插件，请参看这里<a href="http://www.360doc.com/content/15/0417/22/19342630_463999403.shtml" target="_blank" rel="external">编写自己的Sublime Text2 插件</a></li>
</ul>
<h2 id="定制属于自己的快捷键"><strong>定制属于自己的快捷键</strong></h2><ul>
<li>首先要会使用SublimeText内置的快捷键：<br>  比如 <code>Commond Shift P</code> 打开命令面板:例如打开Package Control安装各种插件；可以可以输入Set(Snytax)来改变使用的语言环境，瞬间切换等等。</li>
<li><p>设置快捷键。在SublimeText里，打开Preferences -&gt; Key Bindings - User，我设置的快捷键：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"ctrl+f9"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"build"</span> </span>&#125;,</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"f10"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"build"</span></span>, "<span class="attribute">args</span>": <span class="value">&#123;"<span class="attribute">variant</span>": <span class="value"><span class="string">"Run"</span></span>&#125; </span>&#125;,</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"ctrl+shift+x"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"toggle_comment"</span></span>, "<span class="attribute">args</span>": <span class="value">&#123; "<span class="attribute">block</span>": <span class="value"><span class="literal">true</span> </span>&#125; </span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>  具体可参见这边文章<a href="http://blog.csdn.net/moyan_min/article/details/11530751" target="_blank" rel="external">Sublime Text3 快捷键汇总及设置快捷键配置环境变量</a></p>
</li>
<li><p>定制属于自己的专属快捷键：<br>  比如就拿定制Sublime Text(2/3)编译lua 的快捷键来说：</p>
<ul>
<li><p>首先：下安装lua环境(MAC)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.py | sudo python - install rudix&#10;&#10;&#25110;&#32773;&#65306;curl -O https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.py&#10;sudo python rudix.py install rud</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装IED：SublimeText3;完毕后上面选择:Build System—New Build System 输入：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"/usr/local/bin/lua"</span>, <span class="string">"$file"</span>]</span>,  </span><br><span class="line">    "<span class="attribute">file_regex</span>": <span class="value"><span class="string">"^(...*?):([0-9]*):?([0-9]*)"</span></span>,  </span><br><span class="line">    "<span class="attribute">selector</span>": <span class="value"><span class="string">"source.lua"</span>  </span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>保存为Lua.sublime-build，然后Tools-Build System上就能选择lua来编译脚本了）<br>PS：网上找到的大多数都是 “cmd”: [“lua”, “$file”]可能我是用rudix自动来安装lua的，需要改一下路径。</p>
<p>新建一个xx.lua文件，随便写个语句，选择lua为build system，按一下<code>command+b</code>，就能跑出来了。 如下图所示：<br><img src="http://img2.ph.126.net/PI2F5lnTuwqeBm7KQx56zw==/1871245645272492575.png" alt="LuaShortCutSublimeText"><br>WindowS下面的定制请参看这里<a href="http://www.cnblogs.com/jadeboy/p/4055465.html" target="_blank" rel="external">Sublime Text(2/3)编译lua</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="定制属于自己的主题"><strong>定制属于自己的主题</strong></h2><p>SublimeText 她不仅仅是作为性感无比，强大可大编辑器的存在；要知道在如今这么靠脸吃饭的时代，她的美者这方面怎么可能不臻至完美呢？Mac和Windows都默认十多种不同风格的主题，想必会有您喜欢😍的。即便没有也没关系，我们可以自己定制自己喜欢的风格主题。<a href="http://tmtheme-editor.herokuapp.com/#/local/Monokai" target="_blank" rel="external">在线制作专属Sublime Text主题</a>。这个网址可以轻松按照自己的意愿制作喜欢的主题。完毕之后将生成的xx.sublime.theme文件，点开Preferences -&gt; Browsr Packages这个，放在这个直属目录之下，即可在Theme处选择这个主题了，亲测没有问题。</p>
<p>后记：作为如此便捷的她(Sublime Text3)，值得分享肯定不止这些，在Coding and Writing路上，要继续去发现和发扬她的美，未完待续…</p>
<p>—写于2015.04.17 22:49 ShenZhen@nanshan</p>
<h2 id="些许实用技巧："><strong>些许实用技巧：</strong></h2><p>(1) Ctrl+O(Command+O)可以实现头文件和源文件之间的快速切换 </p>
<p>(2) 通过 View -&gt; Side bar 可在左侧显示当前打开的文件列表 </p>
<p>(3) ST3虽然不像notepad++可以在sidebar上显示函数列表，但是可通过Ctrl+R查看 </p>
<p>(3) 通过 Preference -&gt; Key binding user 可根据个人操作习惯自定义快捷键（包括ST3自带的和插件的） </p>
<p>(4) 双击可选中光标所在单词，三击可选中光标所在行(等同于<code>Ctrl＋L</code>(Command+L));</p>
<p>(5) Ctrl+Shift+T可以打开之前关闭的tab页，这点同chrome是一样的</p>
<p>(6)Ctrl+R定位函数；Ctrl+G定位到行；</p>
<p>(7) 单个文件批量修改：<strong>纯相同的内容</strong>：选中需要修改的内容<code>Alt+F3</code>(Mac下默认的是<code>Ctrl+Command+G</code>) ， 或者连续 Ctrl+D(Win) /连续 Command+D（Mac）之后重新写即可，使用<code>Ctrl + U</code>进行回退，使用Esc退出多重编辑。<br><strong>不纯相同却有一定规律可循的内容</strong>：这个就需要借助SublimeText强大正则的支持了。可以使用<code>Ctrl+H</code>(Mac下是<code>Alt+Command+F</code>)调出：<br><img src="http://i.imgur.com/4NnE9SN.jpg" alt="SublimeText"><br>正则表达式是非常强大的文本查找&amp;替换工具，Sublime Text中使用Alt + R切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="external">Boost里的Perl正则表达式风格</a>。鉴于篇幅，加之本身就对这个不甚熟悉，这里就不再多啰嗦；以下是一些可以参考的文章：</p>
<ul>
<li><a href="http://www.oschina.net/question/12_9507" target="_blank" rel="external">开源中国～正则表达式30分钟入门教程</a></li>
<li><a href="http://www.jeffjade.com/2014/12/25/2014-12-25-regular-expression/" target="_blank" rel="external">59分钟学会正则表达式</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90" target="_blank" rel="external">MSDN～正则表达式语法</a>.aspx)</li>
<li><a href="http://www.williamlong.info/archives/433.html" target="_blank" rel="external">月光博客～常用正则表达式</a></li>
</ul>
<p>(8) 有时我们需要对一片区域的所有行进行同时编辑，<code>Ctrl+Shift+L</code>可以将当前选中区域打散，然后进行同时编辑：<br><img src="http://i.imgur.com/0NHpXFl.gif" alt="SublimeText"></p>
<p>(9)有打散自然就有合并，<code>Ctrl + J</code>(mac下Command＋J)可以把当前选中区域合并为一行：<br><img src="http://i.imgur.com/hfRAyiy.gif" alt="SublimeText"></p>
<p>(10)在<code>Ctrl + P</code>(Command+P)匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p>
<ul>
<li>@ 符号跳转：输入<code>@symbol</code>跳转到symbol符号所在的位置</li>
<li># 关键字跳转：输入<code>#keyword</code>跳转到keyword所在的位置</li>
<li>: 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>
<p>(11)<code>Ctrl + Enter</code>(Mac~Command+Enter)在当前行下面新增一行然后跳至该行；<code>Ctrl + Shift + Enter</code>在当前行上面增加一行并跳至该行。</p>
<p>(12)Sublime Text的查找有不同的模式：<code>Alt + C</code>切换大小写敏感（Case-sensitive）模式，Alt + W切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。</p>
<blockquote>
<p>“auto_find_in_selection”: true</p>
</blockquote>
<p>这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：<br><img src="http://i.imgur.com/QRIsDra.gif" alt="SublimeText"></p>
<p>(13)Windows下<code>Ctrl + ←/→</code>进行逐词移动，相应的，<code>Ctrl + Shift + ←/→</code>进行逐词选择。<br><img src="http://i.imgur.com/jFnTDl3.gif" alt="SublimeText"><br>而Mac下的<code>Command+←/→</code>是从一端移动到另一端；相应的，<code>Command + Shift + ←/→</code>是从一端选择到另一端。</p>
<p>(14) Windows下<code>Ctrl + ↑/↓</code>移动当前显示区域，<code>Ctrl + Shift + ↑/↓</code>移动当前行。<br><img src="http://i.imgur.com/v31pd3k.gif" alt="SublimeText"><br>而Mac下的<code>Command + ↑/↓</code>是从当前行移动到头/尾；相应的，<code>Command + Shift + ↑/↓</code>是从当前行选择到头/尾；</p>
<p>(15)使用<code>Ctrl + N</code>在当前窗口创建一个新标签，<code>Ctrl + W</code>关闭当前标签，<code>Ctrl + Shift + T</code>恢复刚刚关闭的标签。</p>
<p>(16)编辑代码时我们经常会开多个窗口，所以分屏很重要。Windows下：<code>Alt + Shift + 2</code>进行左右分屏，<code>Alt + Shift + 8</code>进行上下分屏，<code>Alt + Shift + 5</code>进行上下左右分屏（即分为四屏）。</p>
<p>(17)Sublime Text基本的手动格式化操作包括：<code>Ctrl + [</code>向左缩进(等同于将一块选中Shift+Tab)，Ctrl + ]向右缩进(等同于将一块选中后Tab键)，<strong>注解：</strong> Ctr+[ 和 Ctr+[ 针对一块连续内容使用，无需选中；此外Ctrl + Shift + V可以以当前缩进粘贴代码（非常实用）。</p>
<p>(18) <del><code>Ctrl+Shift+V</code></del>(好吧，尝试了下Windows下的这个，目测不行，看来须得安装下<a href="https://github.com/kemayo/sublime-text-2-clipboard-history" target="_blank" rel="external">Clipboard-history</a>插件～（粘贴板历史记录）才行啊)（Mac下Command＋Shift＋V），粘贴之时可以调出之前粘贴过的内容（以一个轻量弹框显示以供选择），哇哦，才发现这个功能，感觉棒棒哒😄😄。<br><img src="http://www.jeffjade.com/img/toss/sublimetext-hotkey.png" alt="SublimeText"></p>
<p>(19) Sublime text 删除插件步骤：“Ctrl+Shift+P”—“Remove Package”—“找到需要删除的插件，并点击即可删除”;</p>
<p>(20) 作为强大而小巧，性感且快捷的SublimeText，怎么能够允许不时弹个框提醒你购买或者别的，并且顶部有未注册这样破坏美感的存在呢？OK，输入<a href="http://www.jianshu.com/p/04e1b65dd2c0" target="_blank" rel="external">Sublime text 3最新版破解方法</a>中提供的注册码，就妥妥的哦了。</p>
<hr>
<p>—-更新2015.05.21 15:50 ShenZhen@nanshan<br>对于这个依赖于插件的强大性感无比开源编辑器；优雅的适用之，就在于合理的使用需要的插件，走一条快准狠的键盘一刀流。这个当然可以自己用python来写，但是一般的需求基本上都已经有人完成，还是不浪费时间自己造轮子了。今儿就再赘述一些使用的经验，让使用她可以更加优雅。</p>
<h2 id="插件再推荐(多涉及前端所需)："><strong>插件再推荐(多涉及前端所需)：</strong></h2><p><strong><a href="https://github.com/SublimeText/CTags" target="_blank" rel="external">Ctags插件</a></strong><br>有童鞋抱怨Sublime Text不能支持函数的跳转（比如像Eclipse那样，按住Control点击该方法或者对象，即可跳转到定义的地方； Alt+←即可回到原处）。其实Sublime Text也可以借助插件实现之（当然，有些情况下:Can not find defination）毕竟这个也是借助正则来匹配完成的。因此这个也就要求代码很规范。这个插件相对来讲会有些麻烦，具体的可以参见:<a href="http://firstleaf.diandian.com/post/2013-03-29/40049695682" target="_blank" rel="external">Sublime Text ctags 的配置</a>.</p>
<p><strong><a href="https://github.com/SublimeLinter" target="_blank" rel="external">SublimeLinter插件</a></strong><br>SublimeLinter 是前端编码利器——<a href="http://www.cnblogs.com/lhb25/archive/2012/12/28/best-tools-for-web-development-b.html" target="_blank" rel="external"><strong>Sublime Text</strong></a> 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。<br>比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个<code>SublimeLinter-lua</code>即可。具体的使用可以参见：<a href="http://www.cnblogs.com/lhb25/archive/2013/05/02/sublimelinter-for-js-css-coding.html" target="_blank" rel="external">借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码</a></p>
<p><strong><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements插件</a></strong><br>SideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前，在Sublime Text左侧FOLDERS栏中点击右键，只有寥寥几个简单的功能；安装了就相当于给其丰了大胸一般。<br><strong>更强大的是</strong>，该插件还能让我们自定义快捷键呼出某个浏览器以预览页面！这样就不用到项目目录下寻找和拖动到特定浏览器中预览了。<br>安装此插件后，点击菜单栏的<em>preferences-&gt;package setting-&gt;side bar-&gt;Key Building-User</em>，键入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[   </span><br><span class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"ctrl+shift+c"</span>], <span class="string">"command"</span>: <span class="string">"copy_path"</span> &#125;,</span><br><span class="line">    //chrome</span><br><span class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"f2"</span>], <span class="string">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">            <span class="string">"args"</span>: &#123;</span><br><span class="line">                <span class="string">"paths"</span>: [],</span><br><span class="line">                <span class="string">"application"</span>: <span class="string">"C:\\Users\\jeffj\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe"</span>,</span><br><span class="line">                <span class="string">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里设置按Ctrl+Shift+C复制文件路径，按F2即可在Chrome浏览器预览效果(如果需要的话，也可以根据自己的需要为Firefox，Safari，IE，Opera等加上)，当然你也可以自己定义喜欢的快捷键，最后注意代码中的浏览器路径要以自己电脑里的文件路径为准。</p>
<p><strong><a href="https://github.com/victorporof/Sublime-HTMLPrettify" target="_blank" rel="external">HTML-CSS-JS Prettify</a></strong><br>一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见<a href="http://frontenddev.org/article/sublime-does-text-three-plug-ins-html-and-css-js-prettify.html" target="_blank" rel="external">这篇</a>介绍。</p>
<p><strong><a href="https://github.com/csscomb/CSScomb-for-Sublime" target="_blank" rel="external">CSScomb CSS属性排序</a>:</strong><br>有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。</p>
<p><strong><a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="external">SublimeTmpl 快速生成文件模板</a></strong><br>一直都很奇怪为什么sublime text 3没有新建文件模板的功能，像html头部的DTD声明每次都要复制粘贴。用SublimeTmpl这款插件终于可以解脱了，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。<br>SublimeTmpl默认的快捷键:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctrl+alt+h <span class="tag">html</span></span><br><span class="line">ctrl+alt+j javascript</span><br><span class="line">ctrl+alt+c css</span><br><span class="line">ctrl+alt+<span class="tag">p</span> php</span><br><span class="line">ctrl+alt+r ruby</span><br><span class="line">ctrl+alt+shift+<span class="tag">p</span> python</span><br></pre></td></tr></table></figure></p>
<p>如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就详细介绍了，请各位自己折腾哈~</p>
<p><strong><a href="https://github.com/Pleasurazy/Sublime-JavaScript-API-Completions" target="_blank" rel="external">Javascript-API-Completions</a></strong>:<br>支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。<br><img src="http://www.jeffjade.com/img/toss/sublime-plugin-jq.gif" alt="sublime-jq-plugin"></p>
<p><strong><a href="https://wakatime.com" target="_blank" rel="external">WakaTime</a></strong> — 记录你的Code时间;<br><a href="https://wakatime.com/" target="_blank" rel="external">WakaTime</a>可以做到精确地统计到你花在某个项目上的时间;WakaTime针对不同的IDE，拥有不同的插件，在Sublime上安装着<a href="https://wakatime.com/help/plugins/sublime" target="_blank" rel="external">插件</a>，就能统计到我使用Sublime进行的所有项目的行为。可以高效管理和知晓自己code时间；并且，统计完善, 适合发朋友圈装逼（如果你喜欢的话）~</p>
<blockquote>
<p>Waka的基本设计和rescuetime类似。每个人注册完将获取一个key，装一个客户端，把key输进去（登陆是同一个道理），然后它就把本地的所有行为带个key扔给服务器来统计，一段时间之后给你个报表。不过Waka做的真的很精准，精确到每一个文件用了多少秒，每一种语言用了多少时间。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/82950-b9d7380d0608ecb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>安装和使用都很简单，请参见<a href="https://wakatime.com/help/plugins/sublime-text" target="_blank" rel="external">这里</a>。另外一篇比较详细的文章<a href="https://luolei.org/track-your-time/" target="_blank" rel="external">时间都去哪了?用RescueTime和WakaTime来记录你的时间</a>,对RescueTime和WakaTime有一个更为详细的叙述，可以一读。</p>
<p>剩下些许其他的可以按需安装的插件，比如：</p>
<ul>
<li><strong>ConvertToUTF8</strong>  支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件</li>
<li><strong>Bracket Highlighter</strong> 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效</li>
<li><strong>DocBlockr</strong> 可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++</li>
<li><strong><font color="purple">Emmet(Zen Coding)</font></strong>快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS，当然这个插件还支持多种编译环境，如常见的：Eclipse/Aptana、Coda、Notepad++、Adobe Dreamweaver、TextMate等，web开发必备。</li>
<li><strong>jsFormat</strong> 格式化js代码，懂者自懂；强迫症Coder必备！默认快捷键Ctrl+Alt+F。</li>
<li><strong>phpFormat</strong> 格式化php代码，懂者自懂；强迫症Coder必备！</li>
<li><strong>CSS Compact Expand CSS属性展开收缩:</strong>写CSS的盆友，喜欢将其写多行还是一行(个人喜欢将其格式化为多行)？如果阅读别人的代码不符合自己的习惯，可以用CSS Compact Expand这个插件将CSS格式化一下，按 Ctrl+Alt+[ 收缩CSS代码为一行显示，按 Ctrl+Alt+] 展开CSS代码为多行显示；强迫症Coder必备！。</li>
<li><strong>Autoprefixer插件</strong>：这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有<font color="purple">CanIUse</font>这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。</li>
<li><strong>YUI Compressor</strong>：压缩JS和CSS文件，按F7键后，若压缩当前文件（demo.js），则压缩后的文件（demo.min.js）保存在该文件的同级目录，需要安装java的JDK。使用方法：<a href="http://frontenddev.org/article/sublime-does-text-3-plug-in-yui-compressor.html" target="_blank" rel="external">YUI Compressor</a></li>
</ul>
<hr>
<p>—-更新2015.08.31 11:59 ShenZhen@nanshan—-</p>
<h2 id="Sublime_Text内运行javascript(ES6)"><strong>Sublime Text内运行javascript(ES6)</strong></h2><h4 id="首先安装nodejs">首先安装<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a></h4><p>当然你可以使用其它诸如<a href="https://trac.webkit.org/wiki/JSC" target="_blank" rel="external">jsc</a>之类的环境来运行js, 本文使用的是<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>. 首先确保你的电脑已经安装好nodejs, 并已将其添加到环境变量中 (一般安装时自动添加或者询问是否添加)</p>
<h4 id="添加build_system">添加<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/file_processing/build_systems.html" target="_blank" rel="external">build system</a></h4><p>在sublime text中依次打开Tools -&gt; Build System -&gt; New Build System… 粘贴以下代码后保存(如Node.sublime-build), 然后把Build System设成Automatic<br>{ “cmd”: [“node”, “—use-strict”, “—harmony”, “$file”], “selector”: “source.js”}</p>
<h4 id="附加说明">附加说明</h4><p>在以上的build文件中(Node.sublime-build), node是执行命令, —harmony和—use-strict是执行参数, $file是当前文件名, 所以一次build操作实际上相当于在命令行中执行了node —use-strict —harmony filename<br>. —harmony表示启用<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES Harmony features</a>, 而这些features目前只能在strict模式下运行, 所以需要同时添加use-strict参数(详见<a href="http://stackoverflow.com/questions/17253509/what-is-extended-mode" target="_blank" rel="external">what-is-extended-mode</a>).<br>如果不想启用es6的特性,把build文件更改成以下代码保存即可.<br>{ “cmd”: [“node”, “$file”], “selector”: “source.js”}</p>
<h4 id="具体使用">具体使用</h4><p>在sublime test中新建一个test.js文件, 然后输入你的测试代码, 比如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &#60; 3; i++) &#123;&#10;    console.log(&#39;i:&#39;, i);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用快捷键 <code>ctrl + b</code><br>, 将得到以下执行结果:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">i:</span> <span class="number">0</span><span class="string">i:</span> <span class="number">1</span><span class="string">i:</span> <span class="number">2</span>[Finished <span class="keyword">in</span> <span class="number">0.1</span>s]</span><br></pre></td></tr></table></figure></p>
<p><strong>温馨注解:</strong></p>
<ul>
<li>(1)文件必须是存在于磁盘中的, 而不是untitled的, 否则sublime无法找到相应的文件.</li>
<li>(2)Nodejs安装目录需要加入path环境变量中，否则Ctrl+B运行 会出现：[WinError 2] 系统找不到指定的文件。</li>
</ul>
<h2 id="写在一路更来的结语："><strong>写在一路更来的结语：</strong></h2><p>不得不说的是此篇文章的命名，较之于内容来讲是大了很多。毕竟要优雅使用某个工具，并不是件很容易的事。一边发现学习，一边总结更新，到此已5个月整。然而，对她～SublimeText3三的使用和了解也是仅仅限于一般水平而已。只能说：每个人都工具的使用都怀有不同的态度和追求；但是，<strong>工欲善其事，必先利其器</strong>；此一点总是没错的。因此，在投资自己这里，除学习知识之外，工具的使用大抵就是最应该投资学习的，再次可以是蓝股等等，一如Google工程师@徐宥<a href="http://blog.youxu.info/2008/03/10/tools-everywhere/" target="_blank" rel="external">工具的强是无敌的</a>所言。</p>
<p>所谓，一个好汉三个帮；欲要优雅使用一个工具，辅助器具是必不可少的。而在于Win下以SublimeText来编程或者写作，譬如<strong>AutoHotKey</strong>，<strong>Listary</strong>等对个人来讲着实已成必备工具(在Mac下，有Alfred在手，可以说是天下我有)；其给人带来的方便快捷和意想不到的惊喜，足以可以令其称为Win下小众软件中实用最。当然，像<strong>AutoHotKey</strong>这种在乎于人强，其功能愈发强的工具，其修行之路漫漫，还当上下以求索之(15.09.17更)。</p>
<p>当然，也不能盲目停留在SublimeText这孤傲的世界里。虽性感强大如斯，毕竟也已逝老牌儿范儿了。新的时代总会崛起些新秀，比如Github出品的<code>Atom</code>许有赶超Sublime之势，目测充盈着些许不同的理念；有时间定当去学习下，知乎有话题：<a href="http://www.zhihu.com/question/22867204" target="_blank" rel="external">如何评价 Github 发布的文本编辑器 Atom？</a>，可预先了解下。</p>
<p>最后寄语：<br><strong>工欲善其事，必先利其器！</strong><br><strong>公欲善其事，必先利其器！</strong></p>
<p>参考文章出处：<br><a href="http://www.cnblogs.com/figure9/p/sublime-text-complete-guide.html" target="_blank" rel="external">Sublime Text 全程指引 by Lucida</a><br><a href="http://www.cnblogs.com/bugs/p/3533216.html" target="_blank" rel="external">Sublime Text 3能用支持的插件推荐</a><br><a href="http://www.cnblogs.com/Leo_wl/p/4478147.html" target="_blank" rel="external">Wakatime 测试工作时间</a></p>
<p><a href="http://www.jeffjade.com/2015/04/17/2015-04-17-toss-sublime-text/" target="_blank" rel="external">原文首贴链接:http://www.jeffjade.com/2015/04/17/2015-04-17-toss-sublime-text/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。</p>]]>
    
    </summary>
    
      <category term="SublimeText" scheme="http://jeffjade.github.io/tags/SublimeText/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[以Backbone仿写自己的Todos]]></title>
    <link href="http://jeffjade.github.io/2015/09/07/2015-09-07-jadetodos/"/>
    <id>http://jeffjade.github.io/2015/09/07/2015-09-07-jadetodos/</id>
    <published>2015-09-07T06:30:00.000Z</published>
    <updated>2015-09-24T13:35:42.000Z</updated>
    <content type="html"><![CDATA[<p>学习基本是从模仿开始；对于编程其实也一样。构建todo列表(这个小应用个人很喜欢)无疑是一种学习Backbone规则的很好方式。参考《Backbone.js应用程序开发～Addy Osmani》一文和<a href="http://todomvc.com" target="_blank" rel="external">TodoMVC</a>，前段时间也仿制了自己的<a href="/jadeTodo/index.html">JadetodoS</a>；业余，可以根据自己持续变更的知识,喜好和想法，不断地丰富她，想想都是一件很美好的事儿。倘若可以做出点不一样的改变，哇哦，简直可谓一举数得耶；如此这般期待着，也当这样前行！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习基本是从模仿开始；对于编程其实也一样。构建todo列表(这个小应用个人很喜欢)无疑是一种学习Backbone规则的很好方式。参考《Backbone.js应用程序开发～Addy Osmani》一文和<a href="http://todomvc.com" target="]]>
    </summary>
    
      <category term="Backbone" scheme="http://jeffjade.github.io/tags/Backbone/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IOS 8 Safari JIT bug影响jQuery和underscore]]></title>
    <link href="http://jeffjade.github.io/2015/09/06/2015-09-06-ios8-safari-jitbug-record/"/>
    <id>http://jeffjade.github.io/2015/09/06/2015-09-06-ios8-safari-jitbug-record/</id>
    <published>2015-09-06T03:00:00.000Z</published>
    <updated>2015-10-06T10:28:09.000Z</updated>
    <content type="html"><![CDATA[<p>前端时间为移动游戏做一个网页活动需求（9宫格的刮奖），遇到一个很诡异的问题:Android端OK，就是在Ios设备上，点击非第一块区域，显示却是第一块区域被刮开咯，查看后端返回数据缺失OK的【前端采用backbone写法，遍历返回数据用的是underscore.js中的each】。经过一番查证，原来如此。</p>
<a id="more"></a>
<p>参考<a href="http://www.newsmth.net/nForum/#!article/WebDev/36711" target="_blank" rel="external">水木社区</a>这里的叙述，知晓原来这个属于：IOS 8 Safari JIT bug 影响 jQuery 和 underscore，致使： $.each/<em>.each，看到 .length 后，会把一个 object 当作数组来遍历。这个bug 会造成莫名其妙的结果。而我那里的结果就是：object数据对象，会在</em>.each遍历之后被乱序了。然后就造成以上所描述的问题。</p>
<p>于此，当时的解决办法是:将后端返回的object对象数据，做了转数组处理后，set给定义的模板，交付给_.each遍历就没有问题了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrList = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">	arrList.push(data.datainit.list[i]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">this</span>.model.set(<span class="string">'arrList'</span>,arrList);</span><br></pre></td></tr></table></figure>
<p>好吧,可以看到这里for循环用的是这种传统的方式（还有一个魔数9,额の）。一开始，这里用for..in方式进行遍历的，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> data.datainit.list)&#123;</span><br><span class="line">  arrList.push(data.datainit.list[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>惊奇的结果是：这样搞，不行的;好奇怪的样子(得更努力的深入Js才行哇～)？在chrome的console下比较两者转化的数组结果一模一样。然后以ipod机器（系统版本Ios8.4.1）alert数组的长度，得到的结果是一样的，都是9。额，奇怪啊。就在即将放弃的时候alert了下转化数组结果，发现采用for..in 方式遍历object对象数据，在ios机器上（没试过所有，拿了ipad，iphone相对高版本系统）会打乱原有的顺序（原来以为是以value从大到小呢，后来多次尝试，不是如此，也未发现规律）；可见,<strong>Ios8 Safari上，以for..in方式遍历object对象会造成乱序;</strong>但是为何会造成这样子呢？按照Jquery方面对此问题的修复时说法，此时该Object对象the highest property is 10，且是从data.datainit.list[1]开始轮询的～😄。</p>
<p>JQuery方面在 <a href="https://github.com/jquery/jquery/issues/2145" target="_blank" rel="external">https://github.com/jquery/jquery/issues/2145</a> 有过对此问题的叙述：</p>
<blockquote>
<p>There is a timing bug in iOS8 that causes mobile Safari to incorrectly report a ‘length’ on objects that don’t have one.</p>
<p>To the best of my knowledge, this happens on iOS8+, possibly only on 64-bit systems. The bug is triggered for objects that have only numeric properties. For example:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = &#123; <span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In this case, if you query foo.length then mobile Safari will sometimes return 4 (the highest property + 1).</p>
<p>This causes functions like $.each() to treat objects such as foo above as arrays instead of objects, and when it tries to iterate them as such it fails since there is no foo[0].</p>
<p>The problem can be fixed in the function isArrayLike(). Instead of just checking for </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> length === <span class="string">"number"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>you also need to check for</p>
<p>obj.hasOwnProperty(‘length’)<br>The latter check is immune to the iOS bug.</p>
<p>I realize this is a fix just for one browser, but it’s a browser with a very large user base.</p>
</blockquote>
<hr>
<p>当然：jQuery 1.11.3 和 underscore 1.8.3修正了这个问题。事实上，对于此问题：jquery方面在Github这里<a href="https://github.com/jquery/jquery/issues/2145" target="_blank" rel="external">$.each fails intermittently on iOS due to Safari bug#2145</a>有过相关的论述；有兴趣一探究竟，可以点进去看下。</p>
<p>来对比下underscore 1.7.0和underscore1.8.3中_.each的代码差异，来窥测下其修正手法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The cornerstone, an `each` implementation, aka `forEach`. Handles raw objects in addition to array-likes. Treats all sparse array-likes as if they were dense.   _.each = _.forEach = function(obj, iteratee, context) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  iteratee = createCallback(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length = obj.length;</span><br><span class="line">  <span class="keyword">if</span> (length === +length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;   &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在underscore1.8.3中，做了如下改进，并附有相应注释：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for collection methods to determine whether a collection</span></span><br><span class="line"><span class="comment">// should be iterated as an array or as an object</span></span><br><span class="line"><span class="comment">// Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength</span></span><br><span class="line"><span class="comment">// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094</span></span><br><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span><span class="params">(collection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> property = <span class="function"><span class="keyword">function</span><span class="params">(key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Collection Functions</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The cornerstone, an `each` implementation, aka `forEach`.</span></span><br><span class="line"><span class="comment">// Handles raw objects in addition to array-likes. Treats all</span></span><br><span class="line"><span class="comment">// sparse array-likes as if they were dense.</span></span><br><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span><span class="params">(obj, iteratee, context)</span> </span>&#123;</span><br><span class="line">  iteratee = optimizeCb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端时间为移动游戏做一个网页活动需求（9宫格的刮奖），遇到一个很诡异的问题:Android端OK，就是在Ios设备上，点击非第一块区域，显示却是第一块区域被刮开咯，查看后端返回数据缺失OK的【前端采用backbone写法，遍历返回数据用的是underscore.js中的each】。经过一番查证，原来如此。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[追寻高效工作的一路折腾II]]></title>
    <link href="http://jeffjade.github.io/2015/08/28/2015-08-28-Write-Morkdown/"/>
    <id>http://jeffjade.github.io/2015/08/28/2015-08-28-Write-Morkdown/</id>
    <published>2015-08-28T13:00:00.000Z</published>
    <updated>2015-10-19T10:14:33.000Z</updated>
    <content type="html"><![CDATA[<p>之前有陆续学习和整理关于<a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/" target="_blank" rel="external">追寻高效工作的一路折腾</a>；毕竟技无止境，需要不断的学习总结和对比。而其中诸多内容也是需要分支出来一一细谈(其实就是更为详尽搜集些资料，然后加以整理)；此文就是为了更详尽说明～关于如何更高效的利用SublimeText来写作。</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/26219-29e0b5a286d79092.png?imageView2/2/w/1240/q/100" alt="Sublime Text"></p>
<p>对程序员来讲，写作其实是一件非常有益的事情。这一点不少业界大牛对此已有很深刻的阐述和倡导，比如这里~<a href="http://www.jeffjade.com/2015/02/01/2015-02-01-recommended-article/#程序员" target="_blank" rel="external">吐血推荐文章集锦</a>收录了那些精辟论述;而SublimeText和Markdown结合无疑是一个魔幻的组合。虽然，Markdown在MAC或Win下都有非常多的IDE，比如个人用过的<code>MarkdownPad</code> <code>作业部落</code> <code>简书</code>等，还有Chrome 插件<code>马克飞象</code>  MAC下的<code>Ulysses</code> <code>Mou</code>云云。月光博客的<a href="http://www.williamlong.info/archives/4319.html" target="_blank" rel="external">好用的Markdown编辑器一览</a>对这些有过更详细的总结。但是，对于程序员来讲，SublimeText下蛮多插件支持Markdown写作无疑很棒，如此编码写作，就不用在各个IDE间切换，且享受SublimeText精巧性感如斯，岂是不美？</p>
<h2 id="MarkdownEditing：Sublime_Text的Markdown利器"><strong>MarkdownEditing：Sublime Text的Markdown利器</strong></h2><p>Github项目地址：<a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">SublimeText-Markdown/MarkdownEditing</a></p>
<h3 id="关于安装："><strong>关于安装：</strong></h3><p>如果Sublime安装了Package Control,直接Command+Shift+P(Mac下)输入MarkdownEditing，搜索到点击即可自行安装，重启便可使用用。</p>
<h3 id="关于特性："><strong>关于特性：</strong></h3><p>MarkdownEditing 从视觉和便捷性上针对 Markdown 文档的编辑进行了一系列的优化。具体如下(Mac下)：</p>
<ul>
<li>安装后针对 md\mdown\mmd\txt 格式文件启用插件。颜色方案仿 Byword及iA writer。</li>
<li>自动匹配星号（*）、下划线（_）及反引号（`），选中文本按下以上符号能自动在所选文本前后添加配对的符号，方便粗体、斜体和代码框的输入。</li>
<li>直接输入配对的符号后按下退格键（backspace），则两个符号都会被删除；直接输入配对的符号后按下空格键，则会自动删除后一个。</li>
<li>对“选中文字后输入左括号”这一动作进行了调整，以便插入markdown链接。</li>
<li>拷贝一个链接，选中文本后按下 <strong>⌘⌥V</strong> 会自动插入内联链接。</li>
<li>拷贝一个链接，选中文本后按下 <strong>⌘⌥R</strong> 会自动插入引用链接。</li>
<li><strong>⌘⌥K</strong> 插入链接；<strong>⌘⇧K</strong> 插入图片。</li>
<li><strong>⌘⇧B</strong> 和 <strong>⌘⇧I</strong> 分别用于加粗体和斜体。</li>
<li><strong>⌘^1..6</strong> 对于选中的内容前加对应个数#,即对选中内容字体大小设置为h1~h6;</li>
<li><strong>⌘⇧6</strong>插入文档脚注并且跳转到它的定义；具体可参见:<a href="https://pythonhosted.org/Markdown/extensions/footnotes.html" title="footnotes" target="_blank" rel="external">Footnotes</a>;</li>
<li>选中文本后按下 # 会自动在文本前后进行配对，可重复按下来定义标题级别。</li>
</ul>
<h3 id="关于快捷键："><strong>关于快捷键：</strong></h3><p>无快捷键的编写，即便是Markdown也略显蛋疼。特性中已经对快捷编写有了说明；下面是MarkdownEditing官方给出的三大平台默认Key Bindings说明与对比：</p>
<table>
<thead>
<tr>
<th>OS X</th>
<th style="text-align:center">Windows/Linux</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><kbd>⌘</kbd><kbd>⌥</kbd><kbd>V</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>Win</kbd><kbd>V</kbd></td>
<td>Pastes the contents of the clipboard as an inline link on selected text.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>⌥</kbd><kbd>R</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>Win</kbd><kbd>R</kbd></td>
<td>Pastes the contents of the clipboard as a reference link.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>⌥</kbd><kbd>K</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>Win</kbd><kbd>K</kbd></td>
<td>Inserts a standard inline link.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>⇧</kbd><kbd>K</kbd></td>
<td style="text-align:center"><kbd>Shift</kbd><kbd>Win</kbd><kbd>K</kbd></td>
<td>Inserts an inline image.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>⌥</kbd><kbd>B</kbd> <kbd>⌘</kbd><kbd>⌥</kbd><kbd>I</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>B</kbd> <kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>I</kbd></td>
<td>These are bound to bold and italic. They work both with and without selections. If there is no selection, they will just transform the word under the cursor. These keybindings will unbold/unitalicize selection if it is already bold/italic.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>^</kbd><kbd>1…6</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>1…6</kbd></td>
<td>These will add the corresponding number of hashmarks for headlines. Works on blank lines and selected text in tandem with the above headline tools. If you select an entire existing headline, the current hashmarks will be removed and replaced with the header level you requested. This command respects the <code>mde.match_header_hashes</code> preference setting.</td>
</tr>
<tr>
<td><kbd>⌘</kbd><kbd>⇧</kbd><kbd>6</kbd></td>
<td style="text-align:center"><kbd>Ctrl</kbd><kbd>Shift</kbd><kbd>6</kbd></td>
<td>Inserts a footnote and jump to its definition. If your cursor is in a definition, it will jump back to the marker.</td>
</tr>
<tr>
<td><kbd>⌥</kbd><kbd>⇧</kbd><kbd>F</kbd></td>
<td style="text-align:center"><kbd>Alt</kbd><kbd>Shift</kbd><kbd>F</kbd></td>
<td>Locates footnote markers without definitions and inserts their markers for the definition.</td>
</tr>
<tr>
<td><kbd>⌥</kbd><kbd>⇧</kbd><kbd>G</kbd></td>
<td style="text-align:center"><kbd>Alt</kbd><kbd>Shift</kbd><kbd>G</kbd></td>
<td>Locates link references without definitions and inserts their labels at the bottom for the definition.</td>
</tr>
</tbody>
</table>
<h3 id="关于配置:"><strong>关于配置</strong>:</h3><p>有些快捷键可能与系统的一些发生冲突，可以编辑 ~/Library/Application Support/Sublime Text/Packages/MarkdownEditing/Default (OSX).sublime-keymap 改掉。</p>
<p>另外还有一些设置可以在 ~/Library/Application Support/Sublime Text 2/Packages/MarkdownEditing/Markdown.sublime-settings 中进行修改。</p>
<p>比如除了默认的颜色主题外，MarkdownEditing 还提供了一个高亮显示编辑行 MarkdownEditor-Focus，就可以在 Markdown.sublime-settings 这个文件中找到并去掉注释保存生效。</p>
<h3 id="小小总结："><strong>小小总结：</strong></h3><p>如何对SublimeText本身能够有一个良好的运用，外加上些许插件的组合，无疑可以让SublimeText下编码和下作变得专注且舒适。之前有总结一篇<a href="http://www.jeffjade.com/2015/04/17/2015-04-17-toss-sublime-text/" target="_blank" rel="external">如何优雅地使用Sublime Text</a>,对自己效率和强迫症改善颇多；毕竟东西不少，还有待持续学习和更新。</p>
<p>当然SublimeText下面，关于Markdown的插件不止这一款；最初在Win下，就用过<code>markdown preview</code>;也是很棒，具体可以参见之前的一篇文章～<a href="http://www.cnblogs.com/jadeboy/p/4165449.html" target="_blank" rel="external">Sublime text 下的Markdown写作</a>;而更多如<em>MarkdownTOC</em> , <em>Monokai Extended &amp; Markdown Extended</em>等等@太极儒<a href="http://frank19900731.github.io/blog/2015/04/13/zai-sublime-zhong-pei-zhi-markdown-huan-jing/" target="_blank" rel="external">在 Sublime 中配置 Markdown 环境</a>一文中都有叙述，当然也提到了<code>Pandoc</code>(这个略屌，可将Markdown文章一命令转换成多种格式如Txt,Doc,PDF)这个神器。MacPlay则在<a href="http://macplay.leanote.com/post/%E8%BF%91%E4%B9%8E%E5%AE%8C%E7%BE%8E%E7%9A%84-Markdown-%E5%86%99%E4%BD%9C%E4%BD%93%E9%AA%8C-Sublime-Text-3-OmniMarkupPreviewer" target="_blank" rel="external">近乎完美的 Markdown 写作体验 - Sublime Text 3 + OmniMarkupPreviewer</a>一文中详细的阐述了<font color="purple">OmniMarkupPreviewer</font>的各种美好。生活，行简单以过；折腾，为简单而生！喜欢折腾的朋友肯定能体会到个中益理！</p>
<p><em><strong>更多Markdown编辑器文章：</strong></em><br><a href="http://frank19900731.github.io/blog/2014/12/21/mei-zhou-ruan-zhi-markdown-bi-ji-ruan-jian-ulysses-iii/" target="_blank" rel="external">每周一软之 Markdown 笔记软件 Ulysses II</a><br><a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/#More%20Elegant%20Use%20Markdown" target="_blank" rel="external">More Elegant Use Markdown</a></p>
<p><em>参考的那些链接：</em></p>
<ul>
<li><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">SublimeText-Markdown/MarkdownEditing</a></li>
<li><a href="http://www.cnblogs.com/jadeboy/p/4165449.html" target="_blank" rel="external">Sublime text 下的Markdown写作</a></li>
<li><a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">MarkdownEditing：SublimeText的Markdown 利器</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有陆续学习和整理关于<a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/">追寻高效工作的一路折腾</a>；毕竟技无止境，需要不断的学习总结和对比。而其中诸多内容也是需要分支出来一一细谈(其实就是更为详尽搜集些资料，然后加以整理)；此文就是为了更详尽说明～关于如何更高效的利用SublimeText来写作。</p>]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Markdown" scheme="http://jeffjade.github.io/tags/Markdown/"/>
    
      <category term="SublimeText" scheme="http://jeffjade.github.io/tags/SublimeText/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript字符串间的比较]]></title>
    <link href="http://jeffjade.github.io/2015/08/28/2015-09-02-js-string-compare/"/>
    <id>http://jeffjade.github.io/2015/08/28/2015-09-02-js-string-compare/</id>
    <published>2015-08-28T13:00:00.000Z</published>
    <updated>2015-10-06T10:28:01.000Z</updated>
    <content type="html"><![CDATA[<p>字符串在JavaScript中几乎无处不在，在你处理用户的输入数据的时候，在读取或设置DOM对象的属性时，在操作cookie时，当然还有更 多…。@雪斌在<a href="http://www.cnblogs.com/xuebin/articles/1296837.html" target="_blank" rel="external">JavaScript中的字符串操作</a>一文中讲的很详细，但是对于涉及Js字符串的比较，还是有必要再学习和探究下的。</p>
<a id="more"></a>
<h2 id="字符串和其他对象比较大小"><strong>字符串和其他对象比较大小</strong></h2><p>字符串和其他对象进行比较，大体要遵循下面的这些考量：</p>
<ol>
<li>两个操作数都是数值，则进行数值比较</li>
<li>两个操作数都是字符串，则比较两个字符串对应的字符编码值</li>
<li>两个操作数有一个是数值，则将另一个转换为数值，再进行数值比较</li>
<li>两个操作数有一个是对象，则先调用valueOf()方法或toString()方法，再用结果比较</li>
</ol>
<p>言不如例子，例不如图；然后，请看下面代码：<br><strong>1)纯数字之间比较</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">1</span>&lt;<span class="number">3</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2)数字字符串比较，会将其先转成数字</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"1"</span>&lt;<span class="string">"3"</span>);<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"123"</span>&lt;<span class="string">"123"</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3)纯字符串比较,先转成ascii码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"a"</span>&lt;<span class="string">"b"</span>);<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"abc"</span>&lt;<span class="string">"aad"</span>);<span class="comment">//false,多纯字母比较，会依次比较ascii码</span></span><br></pre></td></tr></table></figure></p>
<p><strong>4)汉字比较</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"我"</span>.charCodeAt());<span class="comment">//25105</span></span><br><span class="line">alert(<span class="string">"的"</span>.charCodeAt());<span class="comment">//30340</span></span><br><span class="line">alert(<span class="string">"我"</span>&lt;<span class="string">"的"</span>);<span class="comment">//true,汉字比较,转成ascii码</span></span><br></pre></td></tr></table></figure></p>
<p><strong>5)当数字和字符串比较，且字符串为数字。则将数字字符串转为数字</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">123</span>&lt;<span class="string">"124"</span>);<span class="comment">//true,下面一句代码得出124的ascii码为49，所以并不是转成ascii比较</span></span><br><span class="line">alert(<span class="string">"124"</span>.charCodeAt());<span class="comment">//49</span></span><br></pre></td></tr></table></figure></p>
<p><strong>6)当数字和字符串比较,且字符串为非纯数字时,则将非数字字符串转成数字的时候会转换为NaN,</strong>当NaN和数字比较时不论大小都返回false(NaN “Not a Number”。出现这个数值比较少见，以至于我们可以不理它。当运算无法返回正确的数值时，就会返回“NaN”值。NaN 值非常特殊，因为它“不是数字”，所以任何数跟它都不相等，<em>甚至 NaN 本身也不等于 NaN</em> 。 )<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="number">13</span>&gt;<span class="string">"abc"</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="判断两个字符串(/对象)是否相等"><strong>判断两个字符串(/对象)是否相等</strong></h2><ol>
<li>如果一个操作值为布尔值，则在比较之前先将其转换为数值，false转成0，true为1；</li>
<li>如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值</li>
<li>如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较</li>
<li>null与undefined是相等的；avaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</li>
<li>如果一个操作值为NaN，则相等比较返回false（<strong>NaN 本身也不等于 NaN</strong>）唯一能判断NaN的方法是通过isNaN()函数：isNaN(NaN); // true</li>
<li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true，否则，返回false</li>
<li>在全等和不全等的判断上，只有值和类型都相等，才返回true，否则返回false；</li>
<li>注意浮点数的相等比较：浮点数在运算过程中会产生误差；所以：1 / 3 === (1 - 2 / 3); // false。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</li>
</ol>
<p>十言不如一例，请看下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2</span>==<span class="number">2</span>;  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">'2'</span>==<span class="number">2</span>; <span class="comment">//true,'2'会转成数值2</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="literal">false</span> == <span class="number">0</span>; <span class="comment">//true,false转成数值就是0</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="literal">false</span> == <span class="string">"0"</span>; <span class="comment">//true,false转成数值就是0,"0"会转化成0</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">'a'</span>==<span class="string">'A'</span>;  <span class="comment">//false,转换后的编码不一样</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>==<span class="literal">NaN</span>; <span class="comment">//false,只要有NaN，都是false</span></span><br><span class="line"><span class="keyword">var</span> num = &#123;&#125;==&#123;&#125;; <span class="comment">//false,比较的是他们的地址，每个新创建对象的引用地址都不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> height = age;</span><br><span class="line"><span class="keyword">var</span> box = age == height;<span class="comment">//true,引用地址一样，所以相等</span></span><br></pre></td></tr></table></figure></p>
<p>JavaScript有两种相等运算符。一种是完全向后兼容的，标准的”==”，如果两个操作数类型不一致，它会在某些时候自动对操作数进行类型转换，考虑下面的赋值语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strA = <span class="string">"i love you!"</span>;</span><br><span class="line"><span class="keyword">var</span> strB = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"i love you!"</span>);</span><br></pre></td></tr></table></figure>
<p>这两个变量含有相同的字符序列，但数据类型却不同，前者为string，后者为object，在使用”==”操作符时，JavaScript会尝试各种求值，以检测两者是否会在某种情况下相等。所以下面的表达式结果为true： strA == strB。</p>
<p>第二种操作符是”严格”的”===”，它在求值时不会这么宽容，不会进行类型转换。所以表达式strA === strB的值为false，虽然两个变量持有的值相同。<br>有时代码的逻辑要求你判断两个值是否不相等，这里也有两个选择：”!=”和严格的”!==”，它们的关系就类似于”==”和”===”。</p>
<p>“==”和”!=”在求值时会尽可能地寻找值的匹配性，但你可能还是想在比较前进行显式的类型转换，以”帮助”它们完成工作。比如，如果想判断一个用户的输入值（字符串）是否等于一个数字，你可以让”==”帮你完成类型转换：</p>
<blockquote>
<p>if(document.form1.txtAge.value == someNumericVar) { … }</p>
</blockquote>
<p>也可以提前转换：</p>
<blockquote>
<p>if(parseInt(document.form1.txtAge.value) == someNumericVar) { … }</p>
</blockquote>
<p>如果你比较习惯于强类型的编程语言(比如C#,Java等)，那么这里你可以延续你的习惯(类型转换)，这样也会增强程序的可读性。</p>
<p>有一种情况需要注意，就是计算机的区域设置。如果用”&lt;”和”&gt;”来比较字符串，那么JavaScript把它们作为Unicode来比较， 但显然，人们在浏览网页时不会把文本当作Unicode来阅读:) 比如在西班牙语中，按照传统的排序，”ch”将作为一个字符排在”c”和”d”之间。localeCompare()提供了一种方式，可以帮助你使用默认 区域设置下的字符排序规则。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strings;  <span class="comment">// 要排序的字符串数组，假设已经得到初始化</span></span><br><span class="line">strings.sort(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span> </span>&#123; <span class="keyword">return</span> a.localeCompare(b) &#125;);  <span class="comment">// 调用sort()方法进行排序</span></span><br></pre></td></tr></table></figure></p>
<p>@阮一峰在<a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="external">如何判断Javascript对象是否存在</a>中详细的写到如何判断Javascript是否存在；涉及10种不同的写法（据悉有超过50种写法）。值得一提的是，Javascript语言的设计，造成了写一个判断一个Javascript对象是否存在，都得小心翼翼。比如下面写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!myObj) &#123;</span><br><span class="line">　　　myObj = &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据其他脚本语言经验，直觉上这是对的，然而运行这段代码，浏览器会直接抛出ReferenceError错误，导致运行中断。对了，if语句判断myObj是否为空时，这个变量还不存在，所以才会报错。改成下面这样，就能正确运行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!myObj) &#123;</span><br><span class="line">　　<span class="keyword">var</span> myObj = &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>究其原因，在于Javascript语言是”<strong>先解析，后运行</strong>“，解析时就已经完成了变量声明，所以上面的代码实际等同于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj;</span><br><span class="line"><span class="keyword">if</span> (!myObj) &#123;</span><br><span class="line">　	<span class="keyword">var</span> myObj = &#123; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>因为，if语句做判断时，myObj确实已经存在了，所以就不报错了。这就是var命令的”代码提升”（hoisting）作用。Javascript解释器，只”提升”var命令定义的变量，对不使用var命令、直接赋值的变量不起作用，这就是为什么不加var会报错的原因。</p>
</blockquote>
<p>也就是说，程序运行到判断对象是否相等之前，必须确认二者是否都’存在’。否则就会报错：</p>
<blockquote>
<p>ReferenceError: xxx is not defined</p>
</blockquote>
<p>==参考文章链接==：</p>
<p><a href="http://segmentfault.com/a/1190000002423935" title="详解js运算符" target="_blank" rel="external">详解js运算符－segmentfault</a> </p>
<p><a href="http://www.esnsc.com/news655.html" target="_blank" rel="external">js如何比较数字字符串之间大小</a></p>
<p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰－javascript教程</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_judge_the_existence_of_a_global_object_in_javascript.html" target="_blank" rel="external">如何判断Javascript对象是否存在</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>字符串在JavaScript中几乎无处不在，在你处理用户的输入数据的时候，在读取或设置DOM对象的属性时，在操作cookie时，当然还有更 多…。@雪斌在<a href="http://www.cnblogs.com/xuebin/articles/1296837.html">JavaScript中的字符串操作</a>一文中讲的很详细，但是对于涉及Js字符串的比较，还是有必要再学习和探究下的。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Html<a>标签href的困惑记载]]></title>
    <link href="http://jeffjade.github.io/2015/08/15/2015-08-15-html-a-href/"/>
    <id>http://jeffjade.github.io/2015/08/15/2015-08-15-html-a-href/</id>
    <published>2015-08-14T16:00:00.000Z</published>
    <updated>2015-09-24T13:34:24.000Z</updated>
    <content type="html"><![CDATA[<p>近日，在工作中遇到一个小问题(给手游平台做些网页活动，其中牵涉到一个按钮链接，就习以为常的用了<code>&lt;a&gt;</code>标签，Click响应之后走一段js代码逻辑－弹出一个分享微信弹框。Chrome和Android平台都没问题，测试阶段发现Ios平台出现了点问题～弹框闪现一下之后，页面被重新渲染了，自然弹框又被消隐掉了。)，经历一番查证，个中缘由原来如此。</p>
<a id="more"></a>
<p>出现问题后，立马走了段代码逻辑，发现并没任何逻辑问题。并且Chrome和Android平台又都OK的，只是Ios平台有此问题。经验不够丰富情形之下，只能在Ios手机上先Alert下,看下代码走的路线了。代码采用Backbone框架而成，经alert出来的提示，发现Click之后，页面view竟被重新执行了一次。额…逻辑没问题，而类似活动无数，没出现类似问题啊，不明就里～［好桑心，无能为力又无从下手的感觉,好难受］。</p>
<p>之后，请出同事中的前辈帮着Codereview下，终定为出了问题。原是误用这<code>&lt;a&gt;</code>惹出来的。这边见大家都用<code>&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</code>。当然之前偶然看了<font class="pruple">张鑫旭</font>一篇<a href="http://www.zhangxinxu.com/wordpress/2013/01/why-use-href-javascript-void0/" target="_blank" rel="external">《疑问：为什么要使用href=”javascript:void(0);”？》</a>，从中窥测之前多用的是<code>&lt;a href=&quot;javascript:void(0);&quot;&gt;&lt;/a&gt;</code>。但为什么要用这个，他本人也没弄明白，然后读完，我也没明白。而此处，嫌用<code>&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</code>这么长麻烦，就用<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code>这个试了下，唉～可以啊，Android也可以唉，那就用下了（噢，问题就因此埋下了，额额额～v～）。</p>
<p><strong>A Problem Is A Chance For You To Do Your Best！</strong>我坚信这一点。惹出些问题并不见得都是坏事。每每因为自己的造成的这些个问题，反倒收获不少，😄。</p>
<p>之后就去查证了下关于这Html<code>&lt;a&gt;</code>标签的Href属性。超链接的 URL。可能的值：</p>
<blockquote>
<ul>
<li>绝对 URL - 指向另一个站点（比如 href=”<a href="http://www.jeffjade.com&quot;）" target="_blank" rel="external">http://www.jeffjade.com&quot;）</a></li>
<li>相对 URL - 指向站点内的某个文件（href=”index.htm”）</li>
<li>锚 URL - 指向页面中的锚（href=”#top”）</li>
</ul>
</blockquote>
<p>根据网搜得到的答案如下，亲测也的确如此：<br>​<code>&lt;a href=&quot;javascript:void(0)&quot;&gt;点击&lt;/a&gt;</code>: 点击链接后不会回到网页顶部<br><code>&lt;a href=&quot;#&quot;&gt;点击&lt;/a&gt;</code>: 点击后会回到网面顶部;<br>这里的href=”javascript:;”，其中javascript:是伪协议，它可以让我们通过一个链接来调用javascript函数.而采用这个方式 javascript:;可以实现A标签的点击事件运行时，如果页面内容很多，有滚动条时，页面不会乱跳，用户体验更好。点击链接后也不会回到网页顶部。</p>
<p>而对于Href第三点～指向页面中的锚，如下用法：</p>
<ol>
<li>需要转到地方添加，<code>&lt;a href=&quot;#命名&quot;&gt;文字&lt;/a&gt;</code>，注意href值是#开头+英文字母命名</li>
<li>需要在被转到位置添加，<code>&lt;span id=&quot;命名&quot; name=&quot;命名&quot;&gt;&lt;/span&gt;</code>，注意id和name值相同并且与a命名相同(<strong>亲测，id必须跟a命名相同，而span的name则不用！</strong>并且当 href=”#” 之时也会回到页面顶部.)</li>
</ol>
<p>即可得出当使用（href=”#”）之时即有可能会回到页面顶部。但问题是，活动一屏幕足以显示完，无需滑动，Ios手机也是如此。那么使用（href=”#”）在这里是不会影响页面刷新的。得到ios客户端开发的说法是：这样写［使用（href=”#”）］会触发到客户端的监控，从而引发异常。(～这一段，很多疑惑，只是猜测，有待继续学习检验)。</p>
<hr>
<p>此段15-08-19更新：<br>对于这一段的不理解，后来在ios客户端童鞋的帮助下消解了。对于Ios跟js的交互是略有点不同的：<a href="http://blog.csdn.net/mkhgg/article/details/7109097" target="_blank" rel="external"> ios中objective-c与js的交互</a>这篇文章会有讲到。js调用objective-c的方法, 代码应该这么做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc</span><span class="params">(cmd,parameter1)</span>   </span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="built_in">document</span>.write(<span class="built_in">Date</span>());   </span><br><span class="line">    <span class="built_in">document</span>.location=<span class="string">"objc://"</span>+cmd+<span class="string">":/"</span>+parameter1;  <span class="comment">//cmd代表objective-   </span></span><br><span class="line">c中的的方法名，parameter1自然就是参数了  （这里的objc:<span class="comment">//可以随意的去改）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Ios里面有一个监听  http 跳转的方法；一旦有类似<code>http://</code> or <code>objc://</code>他们都可以监听到(像这种 http:// 并不是他们要的 ，而要的是这种 objc:// 这种,所以在跟ios通信时候，都必须这种规则 objc://…。而<strong>href=”#”代表的是本地页面</strong>[页面跳转到页面本身]。如此就能解释了之前出现问题了：ios可以监听到<code>&lt;a href=&quot;#&quot;&gt;点击&lt;/a&gt;</code>这种链接，从而使得页面被刷新。</p>
<hr>
<p>那么很疑惑，为何Android平台没有该问题？最后，也更进一步的疑问：JavaScript中语句最后的分号是可以缺省的，那为何要使用javascript:;而不是javascript:呢？是习惯还是规范，我也很疑惑！我也很疑惑！我也很疑惑！（重要的事情说三遍）</p>
<blockquote>
<p>具有代码洁癖的coder们，没事多写一个分号，圣洁的精神世界杯玷污了，怎么能忍受的了呢？这又不是多多语句，不写分号可能会出现意想不到的情况！（很认同，原话出自：<a href="http://www.zhangxinxu.com/wordpress/2013/01/why-use-href-javascript-void0/" target="_blank" rel="external">张鑫旭</a>）</p>
</blockquote>
<hr>
<p>此段15-08-19 20:06更新：<br>今日在博客园～神人唯吾的<a href="http://www.cnblogs.com/happykakeru/archive/2011/10/24/2222702.html" target="_blank" rel="external"><a>标签的href和onclick属性</a>这篇文章中看到了一个说法：</a></p>
<blockquote>
<p>尽量不要用<code>javascript:</code>协议做为A的href属性，这样不仅会导致不必要的触发window.onbeforeunload事件，在IE里面更会使gif动画图片停止播放。</p>
</blockquote>
<p>这也许是大家默认使用’javascript:;’的一个原因，个中原委，有待于进一步的去摸索。</p>
<p><strong>总结：</strong><code>#</code>包含了一个位置信息默认的锚是#top 也就是网页的上端;<br>而<code>javascript:void(0)</code>仅仅表示一个死链接，没有任何信息。作用类同～javascript:;<br>而<code>javascript:</code>会导致不必要的触发window.onbeforeunload事件等。<br>故此：此处当不依靠href属性做页面跳转时候，最好还是用<code>javascript:;</code>更优一点。</p>
<hr>
<p>Gui求指点，欢求吐槽！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近日，在工作中遇到一个小问题(给手游平台做些网页活动，其中牵涉到一个按钮链接，就习以为常的用了<code>&lt;a&gt;</code>标签，Click响应之后走一段js代码逻辑－弹出一个分享微信弹框。Chrome和Android平台都没问题，测试阶段发现Ios平台出现了点问题～弹框闪现一下之后，页面被重新渲染了，自然弹框又被消隐掉了。)，经历一番查证，个中缘由原来如此。</p>]]>
    
    </summary>
    
      <category term="Html" scheme="http://jeffjade.github.io/tags/Html/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 之 this 详解]]></title>
    <link href="http://jeffjade.github.io/2015/08/03/2015-08-03-javascript-this/"/>
    <id>http://jeffjade.github.io/2015/08/03/2015-08-03-javascript-this/</id>
    <published>2015-08-03T14:30:00.000Z</published>
    <updated>2015-10-06T10:27:52.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript作为一种脚本语言身份的存在，因此被很多人认为是简单易学的。然而情况恰恰相反，JavaScript支持函数式编程、闭包、基于原型的继承等高级功能。由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。本文就采撷些例子以浅显说明在不同调用方式下的不同含义。</p>
<a id="more"></a>
<h3 id="全局的this"><strong>全局的this</strong></h3><p>全局this一般指向全局对象，浏览器中的全局对象就是 window。例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.document === <span class="built_in">document</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">91</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//91</span></span><br></pre></td></tr></table></figure></p>
<h3 id="一般函数的_this"><strong>一般函数的 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>);<span class="comment">//true, global object</span></span><br></pre></td></tr></table></figure>
<p>可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="pi">    "use strict"</span>;<span class="comment">//使用严格模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="literal">undefined</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>严格模式中，函数的 this 为 undefined,因为严格模式禁止this关键字指向全局对象；对于js“严格模式”具体可以看阮一峰先生的<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank" rel="external">Javascript 严格模式详解</a></p>
<h3 id="作为对象方法的函数的_this"><strong>作为对象方法的函数的 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    prop: <span class="number">37</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure>
<p>上述代码通过字面量创建对象 o。</p>
<p>f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#10;    prop: 37&#10;&#125;;&#10;&#10;function independent() &#123;&#10;    return this.prop;&#10;&#125;&#10;o.f = independent;&#10;console.log(o.f()); // 37</span><br></pre></td></tr></table></figure></p>
<p>上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 o.f = independent 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。</p>
<h3 id="作为函数调用"><strong>作为函数调用</strong></h3><p>函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoSense</span><span class="params">(x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.x = x; </span><br><span class="line">&#125; </span><br><span class="line">makeNoSense(<span class="number">5</span>); </span><br><span class="line">x;<span class="comment">// x 已经成为一个值为 5 的全局变量</span></span><br></pre></td></tr></table></figure></p>
<p>对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题。以下面moveTo方法为例，内定义两个函数，分别将 x，y 坐标进行平移。结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">    x : <span class="number">0</span>, </span><br><span class="line">    y : <span class="number">0</span>, </span><br><span class="line">    moveTo : <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="keyword">var</span> moveX = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.x = x;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">        &#125;; </span><br><span class="line">        <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="keyword">var</span> moveY = <span class="function"><span class="keyword">function</span><span class="params">(y)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">this</span>.y = y;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">        &#125;; </span><br><span class="line"></span><br><span class="line">        moveX(x); </span><br><span class="line">        moveY(y); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line"><span class="built_in">console</span>.log(point.x) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(point.x) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(x)       <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(y)       <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的this应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的JavaScript程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。</p>
<h3 id="对象原型链上的this"><strong>对象原型链上的this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>通过 var p = Object.create(o) 创建的对象，p 是基于原型 o 创建出的对象。</p>
<p>p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。</p>
<h3 id="get/set_方法与_this"><strong>get/set 方法与 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modulus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.re * <span class="keyword">this</span>.re + <span class="keyword">this</span>.im * <span class="keyword">this</span>.im);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    re: <span class="number">1</span>,</span><br><span class="line">    im: -<span class="number">1</span>,</span><br><span class="line">    get phase() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.im, <span class="keyword">this</span>.re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'modulus'</span>, &#123;</span><br><span class="line">    get: modulus,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.phase, o.modulus); <span class="comment">// -0.78 1.4142</span></span><br></pre></td></tr></table></figure>
<p>get/set 方法中的 this 也会指向 get/set 方法所在的对象的。</p>
<h3 id="构造器中的_this"><strong>构造器中的 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<p>new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="number">24</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//24</span></span><br></pre></td></tr></table></figure></p>
<p>因为返回了对象，将这个对象作为返回值</p>
<h3 id="call/apply_方法与_this"><strong>call/apply 方法与 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(c, d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="number">7</span>); <span class="comment">// "[object Number]"</span></span><br><span class="line">bar.call(); <span class="comment">//[object global]</span></span><br><span class="line">bar.call(<span class="string">"7"</span>);<span class="comment">//[object String]</span></span><br><span class="line">bar.call(<span class="literal">true</span>);<span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(add.call(o,<span class="number">5</span>,<span class="number">7</span>));<span class="comment">//16</span></span><br></pre></td></tr></table></figure>
<h3 id="bind_方法与_this"><strong>bind 方法与 this</strong></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;</span><br><span class="line">    a: <span class="string">"test"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">37</span>,</span><br><span class="line">    f: f,</span><br><span class="line">    g: g</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 37, test</span></span><br></pre></td></tr></table></figure>
<p>绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test</p>
<hr>
<h3 id="JavaScript中this的些许看似怪异现象"><strong>JavaScript中this的些许看似怪异现象</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JavaScript伪协议和内联事件对于this的指向不同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"#"</span> <span class="attribute">onclick</span>=<span class="value">"alert(this.tagName);"</span>&gt;</span>click me<span class="tag">&lt;/<span class="title">a</span>&gt;</span> <span class="comment">&lt;!--弹出A--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert(this.tagName);"</span>&gt;</span>click me<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  <span class="comment">&lt;!--弹出undefined--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert(this==window);"</span>&gt;</span>click me<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  <span class="comment">&lt;!--弹出true--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"btn"</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">value</span>=<span class="value">"this demo"</span> <span class="attribute">name</span>=<span class="value">"button"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'somebody'</span>;</span><br><span class="line"><span class="keyword">var</span> angela = &#123;</span><br><span class="line">    name: <span class="string">'angela'</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="string">"I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>setTimeout和setInterval也会改变this的指向</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">angela.say();<span class="comment">//I'm  angela</span></span><br><span class="line">setTimeout(angela.say, <span class="number">1000</span>);  <span class="comment">//I'm  somebody</span></span><br><span class="line">setInterval(angela.say, <span class="number">1000</span>); <span class="comment">//I'm  somebody</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为<code>setTimeout</code>等函数内this默认的指向是Window。这一点类似于曾探所写的《JavaScript设计模式与开发实践》中提到的<code>丢失的this</code>。看下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">    myName = <span class="string">'jeff'</span>,</span><br><span class="line">    getName = functon()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.myName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">//jeff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName2 = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log( getName2() ); <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//调用getName2时是普通函数方式，this指向全局window，故而结果是undefined；</span></span><br></pre></td></tr></table></figure></p>
<p><strong>on…也会改变this的指向</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">angela.say(); <span class="comment">//I'm  angela</span></span><br><span class="line">btn.onclick = angela.say; <span class="comment">//I'm  button</span></span><br></pre></td></tr></table></figure></p>
<p><strong>click等回调也会改变this指向</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click = angela.say;  <span class="comment">// I'm  button</span></span><br><span class="line">$(<span class="string">"#btn"</span>).click(angela.say);   <span class="comment">// I'm  button</span></span><br></pre></td></tr></table></figure></p>
<p>如果在say中用了this，this会绑定在angela上么？显然这里不是，赋值以后，函数是在回调中执行的，this会绑定到$(“#btn”)元素上。<strong>这个函数被完整复制到onclick属性（现在成为了函数）。因此如果这个even thandler被执行，this将指向HTML元素;</strong>因此，结果显示的是”I’m button”。而，匿名函数可以调整this指向,EG:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; </span><br><span class="line">    angela.say();  <span class="comment">//I'm  angela</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这是JavaScript新手们经常犯的一个错误，为了避免这种错误，许多JavaScript框架都提供了手动绑定 this 的方法。比如Dojo就提供了lang.hitch，该方法接受一个对象和函数作为参数，返回一个新函数，执行时this绑定到传入的对象上。使用 Dojo，可以将上面的例子改为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.onclick = lang.hitch(angela, angela.say);</span><br></pre></td></tr></table></figure></p>
<p>其实在我们使用比较多的jQuery也提供了对应的解决方案：<strong>jQuery.proxy(function, scope)</strong>.返回一个新函数，并且这个函数始终保持了特定的作用域。其作用跟Dojo就提供了lang.hitch类似，具体可以参考<a href="http://www.zhangxinxu.com/jq/api14/jQuery.proxy_function_scope.php" target="_blank" rel="external">这里</a>。其中有一例如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"test"</span>&gt;Click Here!<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span> //html Code</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: "John",</span><br><span class="line">  test: function() &#123;</span><br><span class="line">    alert( this.name );</span><br><span class="line">    $("#test").unbind("click", obj.test);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$("#test").click( jQuery.proxy( obj, "test" ) );</span><br><span class="line">//强制设置函数的作用域，让this指向obj而不是#test对象。</span><br><span class="line"></span><br><span class="line">// 以下代码跟上面那句是等价的:</span><br><span class="line">// $("#test").click( jQuery.proxy( obj.test, obj ) );</span><br><span class="line"></span><br><span class="line">// 可以与单独执行下面这句做个比较。</span><br><span class="line">// $("#test").click( obj.test );</span></span><br></pre></td></tr></table></figure></p>
<p>在新版的 JavaScript 中，已经提供了内置的 bind 方法供大家使用。</p>
<p><strong>匿名函数调整this指向</strong>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; angela.say(); &#125;, <span class="number">1000</span>); <span class="comment">//I'm  angela</span></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; angela.say(); &#125;, <span class="number">1000</span>) <span class="comment">//I'm  angela</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; angela.say(); &#125;;     <span class="comment">//I'm  angela</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; alert(<span class="keyword">this</span> == <span class="built_in">window</span>); &#125;, <span class="number">1000</span>);<span class="comment">//true</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; alert(<span class="keyword">this</span> == btn); &#125;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>匿名函数赋值给了click属性(好吧，现在成了函数)，此时这个匿名函数指向的即是Html属性。因此所调用的函数(比如angela.say())this上下文没有被更改，所以其打印出来的结果就是’I’m  angela’。事实上，也用这样的方法来消解this在回调函数中不堪使用的’特色’(毕竟一旦出了问题难以调试)。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span> == <span class="keyword">this</span>)&#123;</span><br><span class="line">        alert(<span class="string">"window == this"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">"window != this"</span>)  <span class="comment">//弹出来</span></span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="keyword">this</span>.name); <span class="comment">// button</span></span><br><span class="line">    angela.say();    <span class="comment">//I'm  angela</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>将this指向的对象保存到变量(一般用that)</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mydemo = &#123;</span><br><span class="line">    name: <span class="string">'angela'</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; alert(<span class="string">"I'm "</span> + <span class="keyword">this</span>.name); &#125;,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            that.say();  <span class="comment">//弹出Alert：I'm angela</span></span><br><span class="line">            <span class="keyword">this</span>.say();  <span class="comment">//这儿报错: undefined is not a function (evaluating 'this.say()')  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mydemo.init();</span><br></pre></td></tr></table></figure></p>
<h3 id="第三方库or框架中的this"><strong>第三方库or框架中的this</strong></h3><p>比如，使用backbone框架中events时间回调中的this，其指向的就是对应的视图，而不是Dom元素，因为该回调时通过events哈希绑定的，实质上也是自对应视图那里callback到对应的函数;</p>
<h3 id="Javascript中的eval_方法"><strong>Javascript中的eval 方法</strong></h3><p>JavaScript 中的 eval 方法可以将字符串转换为 JavaScript 代码，使用 eval 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval 方法，调用者的执行环境（ExecutionContext）中的 this 就被 eval 方法继承下来了。(悪，还没用过,有待实践下)！<br><em>但是：</em>在严格模式之下，eval的作用域也被改变了。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">　"use strict"</span>;</span><br><span class="line">　　<span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">　　<span class="built_in">console</span>.info(<span class="built_in">eval</span>(<span class="string">"var x = 5; x"</span>)); <span class="comment">// 5</span></span><br><span class="line">　　<span class="built_in">console</span>.info(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p><strong>后记：</strong>由于javascript的动态性（解释执行，当然也有简单的预编译过程），this的指向在运行时才确定，因此在只要足够留心其运行时的上下文，即可无痛挥霍this的强大。上面列举了这么些许，也是要说明另一个问题：即便知道了这个本质，到底还是需要了解各种环境的差异，方可运用自如。比如这篇<a href="http://segmentfault.com/a/1190000002675091" target="_blank" rel="external">JavaScript:万恶的this拿命来（一）</a>文章还谈及：node脚本，还有<code>REPL</code>(“读取-求值-输出”循环（Read-Eval-Print Loop，简称REPL）)中使用this的些许区别，可以一览。</p>
<p>参考A<a href="http://gaohaoyang.github.io/2015/06/12/JavaScript-this/" target="_blank" rel="external">JavaScript 中的 this</a><br>参考B<a href="http://www.cnblogs.com/liyunhua/p/4509888.html" target="_blank" rel="external">JavaScript中this的一些怪异现象</a><br>参考C<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">Javascript的this用法-阮一峰</a><br>参考D<a href="http://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/" target="_blank" rel="external">深入浅出 JavaScript 中的 this</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript作为一种脚本语言身份的存在，因此被很多人认为是简单易学的。然而情况恰恰相反，JavaScript支持函数式编程、闭包、基于原型的继承等高级功能。由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。本文就采撷些例子以浅显说明在不同调用方式下的不同含义。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac必备软件渐集之ZSH－终极Shell]]></title>
    <link href="http://jeffjade.github.io/2015/07/29/2015-07-29-mac-musthave-software/"/>
    <id>http://jeffjade.github.io/2015/07/29/2015-07-29-mac-musthave-software/</id>
    <published>2015-07-29T11:56:00.000Z</published>
    <updated>2015-10-19T10:11:57.000Z</updated>
    <content type="html"><![CDATA[<p>　　写在码字之前：“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。”——陈素封。很多事情只有真正的去折腾后，才发现她的美丽与魅力。Mac是如此，而这ZSH－Unix传承下来系统的终极Shell亦是如此。</p>
<a id="more"></a>
<p>　　很早就在各种博文中看过ZSH的大名鼎鼎。因Mac下自带的Bash觉得还行就没怎么理会。但开始折腾她，源于<code>池建强</code>先生的<a href="http://zhuanlan.zhihu.com/mactalk/19556676" target="_blank" rel="external">终极 Shell——ZSH</a>，绝对的一种相见恨晚。喜欢在玩儿命令行且没有配置ZSH的盆友们，赶紧刷下这篇文章吧。保证物有所值！其好处就不在多加赘述了。</p>
<h3 id="安装ZSH"><strong>安装ZSH</strong></h3><p>　　目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href="https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会" target="_blank" rel="external">https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会</a> C++」系列，可以让你神功速成，而且是真的。</p>
<blockquote>
<p>如果你用 Mac，恭喜你！输入<code>cat /etc/shells</code>可以看到Mac系统自带这ZSH。<br>如果你用 Redhat Linux，执行：sudo yum install zsh<br>如果你用 Ubuntu Linux，执行：sudo apt-get install zsh<br>如果你用 Windows……去洗洗睡吧。</p>
</blockquote>
<p>　　安装完成后设置当前用户使用 zsh：chsh -s /bin/zsh，根据提示输入当前用户的密码就可以了。</p>
<h3 id="安装oh_my_zsh"><strong>安装oh my zsh</strong></h3><p>安装「oh my zsh」可以自动安装也可以手动安装。<br>自动安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/robbyrussell/oh-my-zsh/raw/master/tools/install.<span class="keyword">sh</span> -O - | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>手动安装：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-<span class="keyword">template</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了：<br><img src="http://pic3.zhimg.com/6bc76a6bbbac6267781dc9e59496d2ce_b.jpg" alt="ZSH"></p>
<h3 id="ZSH_的配置"><strong>ZSH 的配置</strong></h3><p>　　zsh 的配置主要集中在用户当前目录的.zshrc里(在mac的用户目录下<code>ls -a</code>命令就可以看到)，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字：</p>
<p># Customize to your needs…</p>
<p>可以在此处定义自己的环境变量和别名，当然，oh my zsh；在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。接下来进行别名的设置，请看下池建强先生的部分配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> javac=<span class="string">"javac -J-Dfile.encoding=utf8"</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> html=mate   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> rb=mate     <span class="comment"># 在命令行直接输入 ruby 文件，会在 TextMate 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> py=vi       <span class="comment"># 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> js=vi</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> c=vi</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> java=vi</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> txt=vi</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> gz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> bz2=<span class="string">'tar -xjvf'</span></span><br></pre></td></tr></table></figure></p>
<p>zsh 的霸气之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：<code>alias -s html=mate</code>，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz=’tar -xzvf’，表示自动解压后缀为 gz 的压缩包。</p>
<p>总之，<strong>只有想不到，木有做不到</strong>。</p>
<h3 id="折腾ZSH的初衷"><strong>折腾ZSH的初衷</strong></h3><p>　　开始折腾不仅是因为读了池建强先生的那篇博文；近来也是折腾Web前段，每次建立个html页面，因Mac下目测不能直接建立一个文件，只好在Terminal 那里<code>touch</code>一个。可是习惯玩儿Sublime Text的自己，不怎么折腾Vim，那打开该html可酒繁琐咯。总不能每次都拖进去或者使用open吧。而ZSH就可以利用其强大的配置，能针对文件类型设置对应的打开程序，哇哦，完美有木有？</p>
<p>　　那配置ZSH时候遇到点问题还是要记录下的。<code>alias -s html=sublime</code>，很明显这一句无法得到执行（没有配置sublime环境变量）。而参考网络上各种博文比如<a href="http://www.flakor.cn/2014-09-14-714.html" target="_blank" rel="external">MAC 设置环境变量path的几种方法</a>,颇为麻烦且目测并不能很好的工作；几番搜索，几番实践，发现“linux/mac下的自定义命令alias，并保存别名使其永久生效（重启不会失效）”这个方法不错，参见<a href="http://blog.unieagle.net/2012/05/21/linux下的自定义命令alias，并保存别名使其永久生效（重/" target="_blank" rel="external">Here</a>。利用 alias aCommandAlias=’aCommand 一堆参数什么的’比如：</p>
<blockquote>
<p>alias gpush=’git push origin HEAD:refs/for/master’</p>
</blockquote>
<p>　　这样在终端中，只需要输入gpush就ok了。但是只是这样的话，会在重启之后失效，解决办法是编辑~/.bashrc文件(没有的创建一个就好)，每行加入一个alias命令。比如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias cdhome=&#39;cd ~&#39;&#10;alias cdroot=&#39;cd /&#39;&#10;alias gpull=&#39;git pull&#39;&#10;alias gci=&#39;git commit -a&#39;&#10;alias gpush=&#39;git push origin HEAD:refs/for/master&#39;&#10;alias gst=&#39;git status&#39;&#10;alias sublime=&#39;open -a &#34;Sublime Text&#34;&#39; //&#21152;&#20837;Sublime Text</span><br></pre></td></tr></table></figure></p>
<p>保存文件后，运行:<code>source ~/.bashrc(不然不生效）</code>就可以了。如果还不行的话，说明没有~/.bash_profile文件，或者文件中没有执行.bashrc文件。(.bash_profile文件是用户登陆终端的时候会自动执行的文件，一般此文件中会调用.bashrc)如果是这样，需要打开（如果没有的话先创建）文件：<code>~/.bash_profile</code>在里面加入一行：<code>source ~/.bashrc</code>即可！</p>
<p>　　昨晚在Mac下测试一番可以。加上ZSH的配置，只要输入xxx.html,就可以打开该文件，挺爽！</p>
<p>　　所以说：“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。——陈素封”,这一句讲的很好。很好美好就需要从折腾开始。因可能有一点繁琐的折腾，让更多的事儿变得更加简洁。</p>
<p>后记：关于更多ZSH信息请参见<a href="http://zhuanlan.zhihu.com/mactalk/19556676" target="_blank" rel="external">终极 Shell——ZSH</a></p>
<p>－2015-07-29于深圳南山－</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　写在码字之前：“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。”——陈素封。很多事情只有真正的去折腾后，才发现她的美丽与魅力。Mac是如此，而这ZSH－Unix传承下来系统的终极Shell亦是如此。</p>]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Mac" scheme="http://jeffjade.github.io/tags/Mac/"/>
    
      <category term="Share" scheme="http://jeffjade.github.io/tags/Share/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
</feed>
